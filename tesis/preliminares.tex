%!TEX root = tesis.tex
\chapter{Preliminares}
\label{preliminares}

En el presente capítulo presentaremos las definiciones y resultados preliminares comprendiendo desde las definiciones lógicas a fin de fijar notación y terminología, hasta el estado del arte en lo que refiere a la resolución del problema \sat .

\section{Lógica proposicional}
La lógica proposicional es una formalización matemática que se ocupa del estudio exhaustivo de los valores de verdad y su combinación a partir de los operadores conocidos como booleanos. Estos operadores usualmente son la negación ($\neg$), la conjunción ($\land$), la disyunción ($\lor$), la implicación ($\Rightarrow$), etc. Usualmente se suelen tomar como conjunto minimal capaz de representar a todos los operadores binarios la negación ($\neg$) y la disyunción ($\lor$) puesto que estos son un conjunto apropiado que permite expresar a los restantes, pero por comodidad a la hora de presentar el problema a resolver utilizaremos la negación ($\neg$), la conjunción ($\land$) y la disyunción ($\lor$).

La formalización más utilizada, desde un punto de vista matemático, de la lógica proposicional es la desarrollada por el matemático inglés George Boole \cite{boole1847} y conocida como álgebra de Boole, pero a efectos de esta presentación y por comodidad nos concentraremos en su presentación lógica.

\begin{definition}
\defname{Fórmulas bien formadas} 
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, entonces $\mathit{Form} (\mathcal{V})$, el conjunto de fórmulas bien formadas sobre $\mathcal{V}$, es el menor conjunto $F$ tal que:
\begin{itemize}
\item $\mathcal{V}\cup\{\bot, \top\} \subseteq F$, y 
\item para todo $f, f' \in F$, $\{\neg f, f \land f', f \lor f'\} \subseteq F$.
\end{itemize}
\end{definition}

\begin{definition}
\defname{Soporte}
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, se define $\mathit{sop}: \mathit{Form} (\mathcal{V}) \to 2^\mathcal{V}$, el soporte de una fórmula proposicional de la siguiente forma:
\begin{itemize}
\item $\mathit{sop} (\bot) = \emptyset$,
\item $\mathit{sop} (\top) = \emptyset$,
\item $\mathit{sop} (p) = \{p\}$,
\item $\mathit{sop} (\neg \varphi) = \mathit{sop} (\varphi)$,
\item $\mathit{sop} (\varphi \land \psi) = \mathit{sop} (\varphi) \cup \mathit{sop} (\psi)$, y
\item $\mathit{sop} (\varphi \lor \psi) = \mathit{sop} (\varphi) \cup \mathit{sop} (\psi)$.
\end{itemize}
\end{definition}

A continuación, en las siguientes dos definiciones, se presenta la forma en la que la sintaxis presentada anteriormente se interpreta en el conjunto $\{0, 1\}$.

\begin{definition}
\defname{Valuación} 
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, una valuación de las variables proposicionales es una función total $v: \mathcal{V} \to \{0, 1\}$.
\end{definition}

\begin{definition}
\defname{Valuación de términos} 
Sea $\mathcal{V}$ un conjunto infinito numerable de variables y una valuación de las variables $v$, $p \in \mathcal{V}$ y $f, f' \in \mathit{Form}(\mathcal{V})$,  se define $v^*: \mathit{Form}(\mathcal{V}) \to \{0, 1\}$ 
\begin{itemize}
\item $v^*(\bot) = 0$,
\item $v^*(\top) = 1$,
\item $v^*(p) = v(p)$,
\item $v^* (\neg f) = \left\{\begin{array}{ll}0 & \mbox{, si $v^*(f)) = 1$}\\ 1 & \mbox{, si $v^*(f)) = 0$}\end{array}\right.$,
\item $v^* (f \land f') =  \left\{\begin{array}{ll}0 & \mbox{, si $v^*(f) = 0$ ó $v^*(f') = 0$}\\1 & \mbox{, si $v^*(f) = 1$ y $v^*(f') = 1$.}\end{array}\right.$, y
\item $v^* (f \lor f') =  \left\{\begin{array}{ll}0 & \mbox{, si $v^*(f) = 0$ y $v^*(f') = 0$}\\1 & \mbox{, si $v^*(f) = 1$ ó $v^*(f') = 1$.}\end{array}\right.$.
\end{itemize}
\end{definition}

\begin{definition}
\defname{$\models$} 
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $v$ una valuación de las variables proposicionales y $f \in \mathit{Form}(\mathcal{V})$, entonces $v \models_{\mathcal{V}} f$ si y sólo si $v^* (f) = 1$.
\end{definition}

\begin{definition}
Sea $\mathcal{V}$ un conjunto infinito numerable de variables y $\varphi \in \mathit{Form}(\mathcal{V})$, $\varphi$ se dice:
\begin{itemize}
\item satisfacible si y sólo si existe una valuación $v$ tal que $v \models_{\mathcal{V}} \varphi$,
\item tautología si y sólo para toda valuación $v$ $v \models_{\mathcal{V}} \varphi$, y
\item contradicción (o insatisfacible) si y sólo para toda valuación $v$ $v \not\models_{\mathcal{V}} \varphi$.
\end{itemize}
\end{definition}

%La lógica proposicional es la rama de la lógica de estudia los valores de verdad y su combinación a partir de los operadores conocidos como booleanos. Estos operadores usualmente son la negación ($\neg$), la conjunción ($\land$), la disyunción ($\lor$), la implicación ($\Rightarrow$), etc. Usualmente se suelen tomar como conjunto minimal capaz de representar a todos los operadores binarios la negación ($\neg$) y la disyunción ($\lor$) puesto que estos son un conjunto apropiado que permite expresar a los restantes.
%
%La formalización más utilizada, desde un punto de vista matemático, de la lógica proposicional es la desarrollada por el matemático inglés George Boole \cite{boole1847} y conocida como álgebra de boole. En este contexto el objeto de interés serán los términos sintácticos llamados términos booleanos y sus relaciones. La definición siguiente formaliza esta estructura matemática.
%
%\begin{definition}
%\defname{Álgebra de Boole} 
%Un álgebra de Boole es una estructura $\langle S, 0, \cdot, 1, +, - \rangle$ tal que se satisfacen los siguientes axiomas: 
%	\begin{itemize}
%		\item $--p = p$ (involución)
%		\item $p + q = q + p$ y $p \cdot q = q \cdot p$ (conmutatividad)
%		\item $p + (q + r) = (p + q) + r$ y $p \cdot (q \cdot r) = (p \cdot q) \cdot r$ (asociatividad)
%		\item $p + (q \cdot r) = (p + q) \cdot (p + r)$ y $p \cdot (q + r) = (p \cdot q) + (p \cdot r)$ (distributividad)
%		\item $p + 0 = p$ y $p \cdot 1 = p$ (elemento neutro)
%		\item $p + 1 = 1$ y $p \cdot 0 = 0$
%		\item $p + -p = 1$ y $p \cdot -p = 0$ (elemento inverso)
%		\item $p \cdot (p + q) = p$ y $p + (p \cdot q) = p$ (absorción)
%	\end{itemize}
%\end{definition}
%
%Las dos definiciones que siguen presentan la forma en la que se obtienen el conjunto de términos booleanos y el de las fórmulas booleanas que serán los objetos sintácticos con los que trabajaremos de aquí en más.
%
%\begin{definition}
%\defname{Términos booleanos} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables, entonces $\mathit{Term} (\mathcal{V})$, el conjunto de términos booleanos sobre $\mathcal{V}$, es el menor conjunto $T$ tal que:
%\begin{itemize}
%\item $\mathcal{V}\cup\{0, 1\} \subseteq T$, y 
%\item para todo $t, t' \in T$, $\{- t, t \cdot t', t + t'\} \subseteq T$.
%\end{itemize}
%\end{definition}
%
%\begin{definition}
%\defname{Fórmulas booleanas} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables, entonces $\mathit{Form} (\mathcal{V})$, el conjunto de fórmulas booleanas sobre $\mathcal{V}$, es $F$ tal que:
%$$
%F = \{t = t'\ |\ t, t' \in \mathit{Term(\mathcal{V}}\}\ .
%$$
%\end{definition}
%
%Una vez definida la sintaxis con la que trabajaremos, las siguientes definiciones establecen el mecanismo por el cual los objetos sintácticos descriptos serán interpretados en un álgebra particular.
%
%\begin{definition}
%\defname{Valuación} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables y $\langle S, \underline{0}, \underline{\cdot}, \underline{1}, \underline{+}, \underline{-} \rangle$ un álgebra de boole, una valuación de las variables es una función total $v: \mathcal{V} \to S$.
%\end{definition}
%
%\begin{definition}
%\defname{Valuación de términos} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $\langle S, \underline{0}, \underline{\cdot}, \underline{1}, \underline{+}, \underline{-} \rangle$ un álgebra de boole y una valuación de las variables $v$ 
%\begin{itemize}
%\item $v^*(1) = \underline{1}$,
%\item $v^*(0) = \underline{0}$,
%\item para toda $p \in \mathcal{V}$, $v^*(p) = v(p)$,
%\item para todo $t \in \mathit{Term}(\mathcal{V})$, $v^* (- t) = \underline{-} v^*(t)$,
%\item para todos $t, t' \in \mathit{Term}(\mathcal{V})$, $v^* (t \cdot t') = v^*(t) \underline{\cdot} v^*(t')$ y $v^* (t + t') = v^*(t) \underline{+} v^*(t')$.
%\end{itemize}
%\end{definition}
%
%\begin{definition}
%\defname{$\models$} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $\langle S, 0, \cdot, 1, +, - \rangle$ un álgebra de boole, una valuación de las variables $v$ y $t, t' \in \mathit{Term}(\mathcal{V})$, entonces $v \models_{\mathcal{V}} t = t'$ si y sólo si $v^* (t) = v^*(t')$.
%\end{definition}
%
%\begin{definition}
%\defname{Fórmula satisfacible (\sat)} 
%Sea $\mathcal{V}$ un conjunto infinito numerable de variables, un álgebra de boole $\langle S, \underline{0}, \underline{\cdot}, \underline{1}, \underline{+}, \underline{-} \rangle$ y una fórmula booleana $\varphi$, $\varphi$ se dice:
%\begin{itemize}
%\item satisfacible si y sólo si existe una valuación $v$ tal que $v \models_{\mathcal{V}} \varphi$,
%\item tautología si y sólo para toda valuación $v$ $v \models_{\mathcal{V}} \varphi$, y
%\item contradicción (o insatisfacible) si y sólo para toda valuación $v$ $v \not\models_{\mathcal{V}} \varphi$.
%\end{itemize}
%\end{definition}
%
%\begin{remark}
%La estructura $\langle \{0, 1\}, 0, \land, 1, \lor, \neg \rangle$ con los operadores definidos según las tablas:
%$$
%\begin{array}{ccc}
%\begin{array}{|c||c|}
%\hline
%p & \neg p\\
%\hline\hline
%0 & 1\\
%1 & 0\\
%\hline
%\end{array}
%&
%\begin{array}{|c|c||c|}
%\hline
%p & q & p \land q\\
%\hline\hline
%0 & 0 & 0\\
%0 & 1 & 0\\
%1 & 0 & 0\\
%1 & 1 & 1\\
%\hline
%\end{array}
%&
%\begin{array}{|c|c||c|}
%\hline
%p & q & p \lor q\\
%\hline\hline
%0 & 0 & 0\\
%0 & 1 & 1\\
%1 & 0 & 1\\
%1 & 1 & 1\\
%\hline
%\end{array}
%\end{array}
%$$
%\noindent es un álgebra de bool.
%\end{remark}

\begin{definition}
\defname{Restricción}
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $S \subseteq \mathcal{V}$ y $v$ una valuación, se define la restricción de $v$ a $S$, $v|_S:S \to \{0, 1\}$ de la siguiente forma, para toda $p \in S$, $v|_S (p) = v(p)$.
\end{definition}

\begin{remark}
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $S \subseteq \mathcal{V}$, $\varphi \in \mathit{Form}(\mathcal{V})$ y, $v$ y $v'$ valuaciones, si $\mathit{sop}(\varphi) \subseteq S$ y $v|_S = v'|_S$, entonces $v \models_\mathcal{V} \varphi$ si y sólo si $v' \models_\mathcal{V} \varphi$.
\end{remark}

A partir de la observación anterior podemos definir la relación de satisfacción $\models^\mathit{fin}_\mathcal{V}$ en función de la ya presentada relación de satisfacción $\models_\mathcal{V}$ de la siguiente forma:

\begin{definition}
Sea $\mathcal{V}$ un conjunto infinito numerable de variables, $S \subseteq \mathcal{V}$ tal que $\mathit{sop}(\varphi) \subseteq S$, $\varphi \in \mathit{Form}(\mathcal{V})$ y $v$ una valuación, $v|_S \models^\mathit{fin}_\mathcal{V} \varphi$ si y solo si $v \models_\mathcal{V} \varphi$.
\end{definition}

La definición anterior expone un hecho de importancia mayor ya que en la práctica, para determinar la satisfactibilidad de una fórmula proposicional sólo es necesario generar la porción finita de la valuación cuyo dominio está restringido al soporte de dicha fórmula. En adelante, usaremos la palabra valuación refiriéndonos a esta porción finita de una valuación.

\begin{definition} \defname{Literal} 
Se denomina literal a una fórmula proposicional que es o bien de la forma $p$ o bien de la forma $\neg p$ con $p$ una variable proposicional.
\end{definition}

\begin{definition} \defname{Forma Normal Conjuntiva} 
Una fórmula proposicional $\varphi$ se encuentra en Forma Normal Conjuntiva (\cnf por sus siglas en inglés) si la misma es una conjunción de cláusulas, donde cada cláusula es una disyunción de literales. 
\end{definition}

Por ejemplo, la fórmula $\phi = (p \vee q) \wedge (\neg p \vee q)$ se encuentra
en \cnf y posee dos cláusulas $C_1 = p \vee q$ y $C_2 = \neg p \vee q$. Dado que los
conectores lógicos están implícitos cuando una fórmula se encuentra en \cnf
normalmente escribimos $\phi = \conj{\disj{p, q}, \disj{\neg p, q}}$ de modo equivalente.

\begin{definition}
\defname{Fórmulas equivalentes} 
Dado $\mathcal{V}$ un conjunto de variables proposicionales y $\varphi_1, \varphi_2 \in \mathit{Form}(\mathcal{V})$, $\varphi_1$ y $\varphi_2$ son equivalentes (denotado como $\varphi_1 \equiv \varphi_2$) si y solo si para toda valuación $v$, $v \models \varphi_1$ si y solo si $v \models \varphi_2$.
\end{definition}

\begin{remark}\label{obs:cnfequiv}
Dado $\mathcal{V}$ un conjunto de variables proposicionales y $\varphi \in \mathit{Form}(\mathcal{V})$, existe $\psi \in \mathit{Form}(\mathcal{V})$ tal que $\varphi \equiv \psi$ y $\psi$ se encuentra en \cnf.

Más aun, existe $F^{\mathit{cnf}}: \mathit{Form}(\mathcal{V}) \to \mathit{Form}(\mathcal{V})$ tal que para toda $\varphi \in \mathit{Form}(\mathcal{V})$, $F^{\mathit{cnf}} (\varphi)$ está en \cnf. \cite{tseitin83}
\end{remark}




\section{El problema de determinar la satisfactiblidad de una fórmula proposicional}

Como se desprende de lo dicho anteriormente, el problema de determinar la satisfactibilidad de una fórmula proposicional $\varphi$ (también denominado \emph{SAT problem}) consiste en determinar si existe alguna valuación $v$ tal que $v_{\mathit{sop}(\varphi)}^*(\varphi) = 1$. En caso de que dicha
asignación exista decimos que $\phi$ es satisfacible (o simplemente \sat) y la
asignación o valuación (usualmente expresada como $\{ p_1 \mapsto v_1, \ldots, p_n \mapsto v_n \}$ donde 
correspondiente determina un \textbf{modelo} de $\phi$. Es importante notar que en caso
de que una fórmula sea \sat podría existir más de una valuación que haga que la
fórmula sea verdadera. Si no existe ninguna valuación que haga verdadera a
$\phi$ decimos que $\phi$ es insatisfacible (o \unsat).

El problema de determinar si una fórmula proposicional dada es \sat o \unsat pertenece
a la clase de problemas \npc\cite{Cook:1971:CTP:800157.805047}. Es decir que no
se conoce un algoritmo cuya complejidad temporal sea polinomial que pueda determinar si una fórmula es \sat
o \unsat. La importancia que reviste el problema SAT para diversas áreas de las
ciencias de la computación, como ser el diseño de circuitos o la verificación
automática, ha impulsado el desarrollo de algoritmos relativamente eficientes
conocidos comúnmente como \emph{SAT solvers}.

En vista de la Obs.~\ref{obs:cnfequiv} el problema \sat se define equivalentemente
como el problema de determinar si una fórmula en \cnf es satisfacible o no.


\subsection{\emph{SAT Solving}}

Se conoce con el nombre de \emph{SAT solvers} a los algoritmos que permiten
determinar si una fórmula $\phi$ de la lógica proposicional tiene alguna
valuación que la haga verdadera. Esto se lleva a cabo a partir de construir dicha valuación.
El algoritmo general de  \emph{SAT solving} consiste en un algoritmo de \bt que podríamos esquematizar como sigue:

\begin{lstlisting}[mathescape,language=Pascal,frame=single,numbers=left,caption={Algoritmo \emph{naïf}},label=naif] 
NAIF-SAT (F $\in \mathit{Form}(\mathcal{V})$ in CNF)
   if F is a consistent set of literals
      then return true
   if F contains an empty clause
      then return false
   $v$ $\leftarrow$ unassigned-var-from(F)
   G $\leftarrow$ assign(v, 1, F)
   if NAIF-SAT(G)
      then return true
   else
      G $\leftarrow$ assign(v, 0, F)
      return NAIF-SAT(G)
\end{lstlisting}

La mayoría de los \emph{SAT solvers} son variaciones del algoritmo general DPLL\cite{Davis:1962:MPT:368273.368557} (que a su vez se basa en el presentado por Davis y Putnam en \cite{Davis:1960:CPQ:321033.321034}) que presentaremos a continuación, y actúan sobre fórmulas proposicionales expresadas en Forma Normal Conjuntiva (\cnf). 

\begin{definition} 
\defname{Cláusula unitaria} Una cláusula se llama \textbf{unitaria} si
posee un único literal.
\end{definition}

Por ejemplo en la fórmula $\gamma = \conj{\disj{-p}, \disj{q, r}}$ la clásula $\disj{-p}$ es
unitaria. Cuando una fórmula \cnf posee una cláusula unitaria, el único modo de
lograr que la fórmula completa sea verdadera es asignando el valor de verdad
$1$ al único literal dentro de la cláusula unitaria.

\begin{lstlisting}[mathescape,language=Pascal,frame=single,numbers=left,caption={Algoritmo DPLL},label=DPLL] 
DPLL (F $\in \mathit{Form}(\mathcal{V})$ in CNF)
   if F is a consistent set of literals
       then return true
   if F contains an empty clause
       then return false
   for every unit clause l in F
       F $\leftarrow$ unit-propagate(l, F)
   l $\leftarrow$ choose-literal(F);
   return DPLL(F $\land$ l) or DPLL(F $\land$ $\neg$ l)
\end{lstlisting}

El algoritmo presentado en List.~\ref{DPLL}, comúnmente conocido como \emph{DPLL}, es un procedimiento que permite implementar un \ssolver cuyo comportamiento resulta radicalmente más eficiente que el presentado en List.~\ref{naif}. Esta modificación en la eficiencia del procedimiento proviene del tratamiento que se hace de las cláusulas unitarias y cómo la asignación de valores a estas repercute sobre la fórmula que se está analizando. 

Los puntos claves del algoritmo son los que aparecen en las filas identificadas como 2, 4, 7, 8 y 9. En el caso de 2 y 4 porque son los puntos en los que se determina si la fórmula es satisfacible o no. En el caso del condicional que aparece en la fila 2 la fórmula se determina como satisfacible por determinar que ya no restan decisiones para ser tomadas; si F es un conjunto consistente de literales, entonces éste conforma una valuación de las variables proposicionales que satisface la fórmula puesto que si $p \in F$ entonces la valuación construida asigna 1 a $p$, y si $\neg p \in F$ entonces le asigna 0. En el caso de 4, si una cláusula resulta vacía, esto implica que no habrá forma de asignar ningún valor a ninguna variable proposicional de forma de hacerla verdadera y por lo tanto la fórmula no será satisfacible. Las filas 6 y 7 realizan lo que se denomina \emph{unit propagation} o BCP (por el inglés \emph{Boolean Constraint Propagation}): propagar en todas las cláusulas las decisiones ya tomadas, de forma que si un literal aparece en F, se eliminen todas las cláusulas que lo contengan, y se elimine toda aparición de dicho literal negado de cualquier cláusula en que aparezca mencionado. En la fila 8 se lleva a cabo una de las tareas más importantes del procedimiento: determinar cuál será la próxima decisión a tomar a partir de escoger un literal. El orden en que se eligen las variables modifica drásticamente el rendimiento de la herramienta, puesto que así se decide qué fragmento del espacio de búsqueda será explorado primero. Una vez elegido el literal que se utilizará para partir el espacio de búsqueda se aplica el procedimiento recursivamente sobre los dos espacios disjuntos de soluciones determinados por $l$ y por $\neg l$.

La mayor diferencia entre el algoritmo del List.~\ref{DPLL} y el de List.~\ref{naif} es precisamente la introducción de la técnica de BCP. Esta técnica permite aplicar un conjunto de decisiones ya tomadas simplificando la fórmula y reduciendo así el espacio de búsqueda a recorrer. Es sabido \cite{moskewicz:da01} que los \ssolver modernos que implementan esta técnica de propagación invierten aproximadamente el 90\% del tiempo en la realización de esta tarea, y es por esta razón que las partes más críticas de la implementación de un \ssolver son aquellas que están involucradas en la resolución de BCP. Ejemplos de esto son las técnicas, algoritmos y estructuras de datos para representación de cláusulas especialmente concebidas para optimizar BCP, como ser el caso de \emph{Head/Tail} \cite{zhang+:cade97} y, más recientemente, los esquemas basados en \emph{2-watched literals} \cite{moskewicz:da01}. %...\marginpar{mencionar las cosas relevantes como punteros a cláusulas y two watch literals.}


\subsection{Aprendizaje}
Uno de los factores más determinantes en la mejora del rendimiento de los \ssolver modernos ha sido la incorporación de técnicas de aprendizaje de cláusulas derivadas de los conflictos que hacen que bajo una cierta cadena de decisiones la fórmula no sea satisfacible. La idea general es identificar contradicciones inherentes a un cierto conjunto de decisiones y agregar a la fórmula cláusulas que obliguen al \ssolver a descartar todo fragmento del espacio de búsqueda que de una u otra forma las implique.

\begin{definition}
\defname{Cláusulas del problema}
Por \emph{cláusula del problema} nos referimos a una de las cláusulas que forman parte del problema original, es decir alguna de las contenidas en la fórmula CNF provista por el usuario.
\end{definition}

%\begin{definition}
%\defname{Cláusulas aprendidas}
%Una \emph{cláusula aprendida} es una cláusula que, si bien no forma parte del problema original, se sigue del mismo. En particular, toda cláusula aprendida se obtiene por medio de la aplicación de una cantidad finita de pasos de resolución sobre las cláusulas del problema (y/o sobre otras cláusulas aprendidas anteriormente).
%\end{definition}

\begin{definition}
\defname{Cláusulas aprendidas}
Llamaremos \emph{cláusula aprendida} a una cláusula que pueda obtenerse por medio de la aplicación de una cantidad finita de pasos de resolución \cite{?} sobre las cláusulas del problema, y/o sobre cláusulas aprendidas anteriormente.
\end{definition}

\begin{proposition}\label{aprendidasesigue}
Sea $F$ un problema en \cnf y $c$ una cláusula aprendida a partir de $F$. Para toda valuación $v$, $v \models F$ implica $v \models c$.
\end{proposition}
\begin{proof}
Se sigue trivialmente de la definición de resolución para la lógica proposicional.
\end{proof}

\begin{proposition}\label{aprendidassesiguen}
Sea $F$ un problema en \cnf, $C$ un conjunto finito de cláusulas aprendidas a partir de $F$. Para toda valuación $v$, $v \models F$ implica $v \models \bigwedge C$.
\end{proposition}
\begin{proof}
Por inducción en el cardinal de $C$ y usando Prop.~\ref{aprendidasesigue}.
\end{proof}


\begin{proposition}
Sea $F$ un problema en \cnf, $C$ un conjunto finito de cláusulas aprendidas a partir de $F$. Para toda valuación $v$, $v \models F$ si y sólo si $v \models F \land \bigwedge C$.
\end{proposition}
\begin{proof}
La demostración se sigue separando en casos dependiendo de si una valuación dada $v$ satisface o no $F$. Supongamos que $v \models F$, por Prop.~\ref{aprendidassesiguen}, $v \models \bigwedge C$, y consecuentemente, $v \models F \land \bigwedge C$. Si $v \not\models F$, luego $v \not\models F \land \bigwedge C$, por monotonía de la lógica proposicional.
\end{proof}

\begin{remark}
%\defname{Cláusulas aprendidas}
Al adosar una o más cláusulas aprendidas a las del problema no se pierde correctitud ni completitud: el nuevo problema y el anterior son equisatisfacibles. Sin embargo, la presencia de estas cláusulas adicionales sí agrega información en el sentido de orientación de la búsqueda (posiblemente permitiendo detectar futuros conflictos más rapidamente). 
\end{remark}

\begin{definition}
\defname{Nivel de decisión}
Por \emph{nivel de decisión} debe entenderse la cantidad de variables respecto de las cuales se han tomado decisiones arbitrarias (que posiblemente requieran \emph{backtracking}) como parte del proceso de búsqueda. Cada vez que se toma una tal decisión (y se propagan, mediante BCP, todas las implicaciones de la misma y de las anteriores) se está incrementando en 1 el nivel de decisión actual del \ssolver.
\end{definition}



\subsubsection{Análisis de conflictos, UIPs y backjumping}

\begin{definition}
\defname{Conflicto}
Llamaremos \emph{conflicto} a toda situación en la que el \ssolver, como consecuencia de las decisiones tomadas, derive tanto un literal como su negación.
\end{definition}


Cada vez que la cadena de decisiones tomadas --más las implicaciones obtenidas por medio de BCP tras cada una de ellas-- conducen al \emph{solver} a un conflicto, se lleva a cabo un \emph{análisis de conflicto}, cuyos objetivos incluyen:

\begin{itemize}

\item Determinar las causas del conflicto hallado, y caracterizarlas mediante una o más \emph{cláusulas de conflicto} que pueda(n) almacenarse para procurar evitar otros conflictos similares en lo sucesivo.

\item Minimizar esas cláusulas hasta lograr que la caracterización antedicha sea lo más ajustada posible, para así maximizar el potencial de poda del espacio de búsqueda que en lo sucesivo pudiere permitir cada cláusula aprendida. %Esto se conoce como \emph{conflict clause minimization} [cita].

\item  Calcular el punto más alto al que se pueda regresar de modo correcto y completo en la cadena de decisiones (es decir, cuánto restar al nivel de decisión actual), evitando por completo tener que inspeccionar ciertas partes del espacio de búsqueda que, a la luz del conflicto hallado, sólo podrían ser infructuosas. Esto se conoce como \emph{backjumping} o \emph{backtracking no cronológico} \cite{marques-silva:iccad96,moskewicz:da01}.

\end{itemize}

En la actualidad, para aprovechar la estructura del grafo de implicaciones (la clausura recursiva de las razones del conflicto, expresadas en términos de cláusulas, decisiones tomadas y consecuencias implicadas), el análisis de conflictos de la mayor parte de los \ssolvers CDCL suele basarse en la noción de \emph{Unit Implication Point} \cite{marques-silva:iccad96} y en la más reciente de \emph{First UIP} \cite{zhang:iccad01}.


\subsubsection{Recorte de la base de datos}

La acumulación de cláusulas aprendidas en conflictos pasados resulta muy ventajosa, pero no puede más que convertirse en una desventaja si se la implementa de manera irrestricta. En primer lugar, la cantidad de cláusulas aprendidas es proporcional a la de conflictos hallados, que a su vez es --en peor caso-- exponencial en la cantidad de variables. Así, un solver que aprenda pero nunca descarte cláusulas correría el riesgo de agotar la memoria disponible.

En segundo lugar, la proliferación de cláusulas aprendidas conlleva cierto \emph{overhead} en otros aspectos del proceso de búsqueda (y en particular en el corazón del mismo, ya que realizar BCP sobre un mayor número de cláusulas resulta más costoso). En consecuencia, al acumular más y más cláusulas también se corre el riesgo de alcanzar el punto en el que los beneficios de recortar el espacio de búsqueda ya no compensen la penalidad que supone un costo de propagación mucho mayor.

Estos riesgos motivan la necesidad de contar con políticas de purga: todo \ssolver que mantenga una base de datos de cláusulas aprendidas debe implementar algún criterio de borrado parcial periódico.

Surge así la necesidad de decidir cuáles y cuántas de las cláusulas aprendidas descartar, y cuándo o cada cuánto hacerlo. En este sentido se han estudiado, en las últimas dos décadas, diversos enfoques y criterios.



\subsubsection{Longitud, actividad y LBD}
\label{sec:longactlbd}

Un primer factor que naturalmente se tuvo en cuenta es la longitud de las cláusulas aprendidas, en tanto suele ser el caso \cite{marques-silva:iccad96} que las más breves tienen mayor poder de recorte del espacio de búsqueda.

Otra propuesta, que por sus buenos resultados fue adoptada por muchas implementaciones desde entonces \cite{goldberg:date02}, consiste en medir el grado o nivel de \emph{actividad} de las cláusulas aprendidas, observando y contabilizando la cantidad de conflictos futuros en los que cada tal cláusula se ve involucrada.

La mayoría de los \ssolvers CDCL modernos implementan esta métrica mediante alguna variante sencilla del enfoque AIMD (\emph{additive increase, multiplicative decrease}): por lo general se incrementa en alguna constante fija el puntaje de actividad de cada cláusula responsable de un nuevo conflicto, y periódicamente se dividen los puntajes de actividad de todas las cláusulas por una constante fija \cite{een:tast03}.

Más recientemente se ha destacado otra métrica denominada LBD, por \emph{Literals Blocks Distance} \cite{Audemard:2009:PLC:1661445.1661509}.%, que se basa en medir la cantidad de subconjuntos distintos en que pueden particionarse los literales de cada cláusula aprendida según sus respectivos niveles de decisión.
Dados una cláusula $c$ y una partición de sus literales en $n$ subconjuntos acorde con la valuación parcial actual, de modo tal que los literales son particionados según sus respectivos niveles de decisión, decimos que el LBD de $c$ es exactamente $n$.




