!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BoolOption	utils/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption	access:public	signature:(const char* c, const char* n, const char* d, bool v)
BoolOption	utils/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat	inherits:Option
CFLAGS	mtl/template.mk	/^CFLAGS    ?= -Wall -Wno-parentheses$/;"	m
CHDRS	mtl/template.mk	/^CHDRS      = $(wildcard $(PWD)\/*.h)$/;"	m
CMap	core/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
COBJS	mtl/template.mk	/^COBJS      = $(CSRCS:.cc=.o) $(DSRCS:.cc=.o)$/;"	m
COPTIMIZE	mtl/template.mk	/^COPTIMIZE ?= -O3$/;"	m
CRef	core/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat
CRefHash	core/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap	access:private
CRef_Undef	core/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	m	namespace:Minisat
CSRCS	mtl/template.mk	/^CSRCS      = $(wildcard $(PWD)\/*.cc) $/;"	m
CXX	mtl/template.mk	/^CXX       ?= g++$/;"	m
Clause	core/SolverTypes.h	/^    Clause(const V& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause	access:private	signature:(const V& ps, bool use_extra, bool learnt)
Clause	core/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
ClauseAllocator	core/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:()
ClauseAllocator	core/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(uint32_t start_cap)
ClauseAllocator	core/SolverTypes.h	/^class ClauseAllocator : public RegionAllocator<uint32_t>$/;"	c	namespace:Minisat	inherits:RegionAllocator
ClauseDeleted	simp/SimpSolver.h	/^        explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted	access:public	signature:(const ClauseAllocator& _ca)
ClauseDeleted	simp/SimpSolver.h	/^    struct ClauseDeleted {$/;"	s	class:Minisat::SimpSolver	access:protected
DCOBJS	mtl/template.mk	/^DCOBJS     = $(addsuffix d,  $(COBJS))$/;"	m
DEPDIR	core/Makefile	/^DEPDIR    = mtl utils$/;"	m
DEPDIR	simp/Makefile	/^DEPDIR    = mtl utils core$/;"	m
DEPDIR	utils/Makefile	/^DEPDIR    = mtl$/;"	m
DSRCS	mtl/template.mk	/^DSRCS      = $(foreach dir, $(DEPDIR), $(filter-out $(MROOT)\/$(dir)\/Main.cc, $(wildcard $(MROOT)\/$(dir)\/*.cc)))$/;"	m
DeepEqual	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s	namespace:Minisat
DeepHash	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s	namespace:Minisat
DoubleOption	utils/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:Minisat::DoubleOption	access:public	signature:(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))
DoubleOption	utils/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat	inherits:Option
DoubleRange	utils/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:Minisat::DoubleRange	access:public	signature:(double b, bool binc, double e, bool einc)
DoubleRange	utils/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
EXEC	core/Makefile	/^EXEC      = minisat$/;"	m
EXEC	mtl/template.mk	/^EXEC      ?= $(notdir $(PWD))$/;"	m
EXEC	simp/Makefile	/^EXEC      = minisat$/;"	m
EXEC	utils/Makefile	/^EXEC      = system_test$/;"	m
ElimLt	simp/SimpSolver.h	/^        explicit ElimLt(const vec<int>& no) : n_occ(no) {}$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(const vec<int>& no)
ElimLt	simp/SimpSolver.h	/^    struct ElimLt {$/;"	s	class:Minisat::SimpSolver	access:protected
Equal	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s	namespace:Minisat
Hash	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s	namespace:Minisat
HashTable	core/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap	access:private
Heap	mtl/Heap.h	/^    Heap(const Comp& c) : lt(c) { }$/;"	f	class:Minisat::Heap	access:public	signature:(const Comp& c)
Heap	mtl/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
Int64Option	utils/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Minisat::Int64Option	access:public	signature:(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
Int64Option	utils/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat	inherits:Option
Int64Range	utils/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range	access:public	signature:(int64_t b, int64_t e)
Int64Range	utils/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
IntOption	utils/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:Minisat::IntOption	access:public	signature:(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
IntOption	utils/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat	inherits:Option
IntRange	utils/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange	access:public	signature:(int b, int e)
IntRange	utils/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
Key	mtl/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue	access:public
LFLAGS	mtl/template.mk	/^LFLAGS    ?= -Wall$/;"	m
LessThan_default	mtl/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
Lit	core/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
Map	mtl/Map.h	/^                   Map        (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map	access:private	signature:(Map<K,D,H,E>& other)
Map	mtl/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map	access:public	signature:()
Map	mtl/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map	access:public	signature:(const H& h, const E& e)
Map	mtl/Map.h	/^class Map {$/;"	c	namespace:Minisat
MiniSat::memUsedPeak	utils/System.cc	/^double MiniSat::memUsedPeak(void) { return memUsed(); }$/;"	f	class:MiniSat	signature:(void)
Minisat	core/Dimacs.h	/^namespace Minisat {$/;"	n
Minisat	core/Solver.h	/^namespace Minisat {$/;"	n
Minisat	core/SolverTypes.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Alg.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Alloc.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Heap.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Map.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Queue.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Sort.h	/^namespace Minisat {$/;"	n
Minisat	mtl/Vec.h	/^namespace Minisat {$/;"	n
Minisat	mtl/XAlloc.h	/^namespace Minisat {$/;"	n
Minisat	simp/SimpSolver.h	/^namespace Minisat {$/;"	n
Minisat	utils/Options.h	/^namespace Minisat {$/;"	n
Minisat	utils/ParseUtils.h	/^namespace Minisat {$/;"	n
Minisat	utils/System.h	/^namespace Minisat {$/;"	n
Minisat::BoolOption	utils/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat	inherits:Option
Minisat::BoolOption::BoolOption	utils/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption	access:public	signature:(const char* c, const char* n, const char* d, bool v)
Minisat::BoolOption::help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption	access:public	signature:(bool verbose = false)
Minisat::BoolOption::operator =	utils/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(bool b)
Minisat::BoolOption::operator bool	utils/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(void) const
Minisat::BoolOption::operator bool&	utils/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(void)
Minisat::BoolOption::parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption	access:public	signature:(const char* str)
Minisat::BoolOption::value	utils/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption	access:private
Minisat::CMap	core/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
Minisat::CMap::CRefHash	core/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap	access:private
Minisat::CMap::CRefHash::operator ()	core/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash	access:public	signature:(CRef cr) const
Minisat::CMap::HashTable	core/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap	access:private
Minisat::CMap::bucket	core/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap	access:public	signature:(int i) const
Minisat::CMap::bucket_count	core/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap	access:public	signature:() const
Minisat::CMap::clear	core/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap	access:public	signature:()
Minisat::CMap::debug	core/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap	access:public	signature:()
Minisat::CMap::growTo	core/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, const T& t)
Minisat::CMap::has	core/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, T& t)
Minisat::CMap::insert	core/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, const T& t)
Minisat::CMap::map	core/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap	access:private
Minisat::CMap::moveTo	core/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap	access:public	signature:(CMap& other)
Minisat::CMap::operator []	core/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr)
Minisat::CMap::operator []	core/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr) const
Minisat::CMap::remove	core/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr)
Minisat::CMap::size	core/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap	access:public	signature:() const
Minisat::CRef	core/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat
Minisat::CRef_Undef	core/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	m	namespace:Minisat
Minisat::Clause	core/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
Minisat::Clause::Clause	core/SolverTypes.h	/^    Clause(const V& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause	access:private	signature:(const V& ps, bool use_extra, bool learnt)
Minisat::Clause::__anon3::has_extra	core/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon3::learnt	core/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon3::literals_blocks_distance	core/SolverTypes.h	/^	uint32_t literals_blocks_distance; \/\/ As in GLUCOSE 1.1: a solver that predicts learnt clauses quality $/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon3::mark	core/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon3::reloced	core/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon3::size	core/SolverTypes.h	/^        unsigned size      : 27; $/;"	m	struct:Minisat::Clause::__anon3	access:public
Minisat::Clause::__anon4::abs	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
Minisat::Clause::__anon4::act	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
Minisat::Clause::__anon4::lit	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
Minisat::Clause::__anon4::rel	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
Minisat::Clause::abstraction	core/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::activity	core/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Minisat::Clause	access:public	signature:()
Minisat::Clause::calcAbstraction	core/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause	access:public	signature:()
Minisat::Clause::data	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anon4	access:private
Minisat::Clause::has_extra	core/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::header	core/SolverTypes.h	/^	}                            header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anon3	access:private
Minisat::Clause::last	core/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::lbd	core/SolverTypes.h	/^    uint32_t lbd() { return header.literals_blocks_distance; } ;$/;"	f	class:Minisat::Clause	access:public	signature:()
Minisat::Clause::learnt	core/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::mark	core/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::mark	core/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause	access:public	signature:(uint32_t m)
Minisat::Clause::operator []	core/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i) const
Minisat::Clause::operator []	core/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i)
Minisat::Clause::operator const Lit*	core/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause	access:public	signature:(void) const
Minisat::Clause::pop	core/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause	access:public	signature:()
Minisat::Clause::relocate	core/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause	access:public	signature:(CRef c)
Minisat::Clause::relocation	core/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::reloced	core/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::setLbd	core/SolverTypes.h	/^    void     setLbd(uint32_t lbd) { header.literals_blocks_distance = lbd; }$/;"	f	class:Minisat::Clause	access:public	signature:(uint32_t lbd)
Minisat::Clause::shrink	core/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i)
Minisat::Clause::size	core/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
Minisat::Clause::strengthen	core/SolverTypes.h	/^    void         strengthen  (Lit p);$/;"	p	class:Minisat::Clause	access:public	signature:(Lit p)
Minisat::Clause::strengthen	core/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause	signature:(Lit p)
Minisat::Clause::subsumes	core/SolverTypes.h	/^    Lit          subsumes    (const Clause& other) const;$/;"	p	class:Minisat::Clause	access:public	signature:(const Clause& other) const
Minisat::Clause::subsumes	core/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause	signature:(const Clause& other) const
Minisat::ClauseAllocator	core/SolverTypes.h	/^class ClauseAllocator : public RegionAllocator<uint32_t>$/;"	c	namespace:Minisat	inherits:RegionAllocator
Minisat::ClauseAllocator::ClauseAllocator	core/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:()
Minisat::ClauseAllocator::ClauseAllocator	core/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(uint32_t start_cap)
Minisat::ClauseAllocator::ael	core/SolverTypes.h	/^    Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(const Clause* t)
Minisat::ClauseAllocator::alloc	core/SolverTypes.h	/^    CRef alloc(const Lits& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(const Lits& ps, bool learnt = false)
Minisat::ClauseAllocator::clauseWord32Size	core/SolverTypes.h	/^    static int clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator	access:private	signature:(int size, bool has_extra)
Minisat::ClauseAllocator::extra_clause_field	core/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator	access:public
Minisat::ClauseAllocator::free	core/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(CRef cid)
Minisat::ClauseAllocator::lea	core/SolverTypes.h	/^    Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r)
Minisat::ClauseAllocator::lea	core/SolverTypes.h	/^    const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r) const
Minisat::ClauseAllocator::moveTo	core/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(ClauseAllocator& to)
Minisat::ClauseAllocator::operator []	core/SolverTypes.h	/^    Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r)
Minisat::ClauseAllocator::operator []	core/SolverTypes.h	/^    const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r) const
Minisat::ClauseAllocator::reloc	core/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(CRef& cr, ClauseAllocator& to)
Minisat::DeepEqual	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s	namespace:Minisat
Minisat::DeepEqual::operator ()	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:Minisat::DeepEqual	access:public	signature:(const K* k1, const K* k2) const
Minisat::DeepHash	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s	namespace:Minisat
Minisat::DeepHash::operator ()	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:Minisat::DeepHash	access:public	signature:(const K* k) const
Minisat::DoubleOption	utils/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat	inherits:Option
Minisat::DoubleOption::DoubleOption	utils/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:Minisat::DoubleOption	access:public	signature:(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))
Minisat::DoubleOption::help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption	access:public	signature:(bool verbose = false)
Minisat::DoubleOption::operator =	utils/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(double x)
Minisat::DoubleOption::operator double	utils/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(void) const
Minisat::DoubleOption::operator double&	utils/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(void)
Minisat::DoubleOption::parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption	access:public	signature:(const char* str)
Minisat::DoubleOption::range	utils/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption	access:protected
Minisat::DoubleOption::value	utils/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption	access:protected
Minisat::DoubleRange	utils/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
Minisat::DoubleRange::DoubleRange	utils/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:Minisat::DoubleRange	access:public	signature:(double b, bool binc, double e, bool einc)
Minisat::DoubleRange::begin	utils/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange	access:public
Minisat::DoubleRange::begin_inclusive	utils/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange	access:public
Minisat::DoubleRange::end	utils/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange	access:public
Minisat::DoubleRange::end_inclusive	utils/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange	access:public
Minisat::Equal	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s	namespace:Minisat
Minisat::Equal::operator ()	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Minisat::Equal	access:public	signature:(const K& k1, const K& k2) const
Minisat::Hash	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s	namespace:Minisat
Minisat::Hash::operator ()	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Minisat::Hash	access:public	signature:(const K& k) const
Minisat::Heap	mtl/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
Minisat::Heap::Heap	mtl/Heap.h	/^    Heap(const Comp& c) : lt(c) { }$/;"	f	class:Minisat::Heap	access:public	signature:(const Comp& c)
Minisat::Heap::build	mtl/Heap.h	/^    void build(vec<int>& ns) {$/;"	f	class:Minisat::Heap	access:public	signature:(vec<int>& ns)
Minisat::Heap::clear	mtl/Heap.h	/^    void clear(bool dealloc = false) $/;"	f	class:Minisat::Heap	access:public	signature:(bool dealloc = false)
Minisat::Heap::decrease	mtl/Heap.h	/^    void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
Minisat::Heap::empty	mtl/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap	access:public	signature:() const
Minisat::Heap::heap	mtl/Heap.h	/^    vec<int> heap;     \/\/ Heap of integers$/;"	m	class:Minisat::Heap	access:private
Minisat::Heap::inHeap	mtl/Heap.h	/^    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }$/;"	f	class:Minisat::Heap	access:public	signature:(int n) const
Minisat::Heap::increase	mtl/Heap.h	/^    void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
Minisat::Heap::indices	mtl/Heap.h	/^    vec<int> indices;  \/\/ Each integers position (index) in the Heap$/;"	m	class:Minisat::Heap	access:private
Minisat::Heap::insert	mtl/Heap.h	/^    void insert(int n)$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
Minisat::Heap::left	mtl/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
Minisat::Heap::lt	mtl/Heap.h	/^    Comp     lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Minisat::Heap	access:private
Minisat::Heap::operator []	mtl/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap	access:public	signature:(int index) const
Minisat::Heap::parent	mtl/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
Minisat::Heap::percolateDown	mtl/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
Minisat::Heap::percolateUp	mtl/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
Minisat::Heap::removeMin	mtl/Heap.h	/^    int  removeMin()$/;"	f	class:Minisat::Heap	access:public	signature:()
Minisat::Heap::right	mtl/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
Minisat::Heap::size	mtl/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap	access:public	signature:() const
Minisat::Heap::update	mtl/Heap.h	/^    void update(int n)$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
Minisat::Int64Option	utils/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat	inherits:Option
Minisat::Int64Option::Int64Option	utils/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Minisat::Int64Option	access:public	signature:(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
Minisat::Int64Option::help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option	access:public	signature:(bool verbose = false)
Minisat::Int64Option::operator =	utils/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(int64_t x)
Minisat::Int64Option::operator int64_t	utils/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(void) const
Minisat::Int64Option::operator int64_t&	utils/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(void)
Minisat::Int64Option::parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option	access:public	signature:(const char* str)
Minisat::Int64Option::range	utils/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option	access:protected
Minisat::Int64Option::value	utils/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option	access:protected
Minisat::Int64Range	utils/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
Minisat::Int64Range::Int64Range	utils/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range	access:public	signature:(int64_t b, int64_t e)
Minisat::Int64Range::begin	utils/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range	access:public
Minisat::Int64Range::end	utils/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range	access:public
Minisat::IntOption	utils/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat	inherits:Option
Minisat::IntOption::IntOption	utils/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:Minisat::IntOption	access:public	signature:(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
Minisat::IntOption::help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption	access:public	signature:(bool verbose = false)
Minisat::IntOption::operator =	utils/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption	access:public	signature:(int32_t x)
Minisat::IntOption::operator int32_t	utils/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption	access:public	signature:(void) const
Minisat::IntOption::operator int32_t&	utils/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption	access:public	signature:(void)
Minisat::IntOption::parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption	access:public	signature:(const char* str)
Minisat::IntOption::range	utils/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption	access:protected
Minisat::IntOption::value	utils/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption	access:protected
Minisat::IntRange	utils/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
Minisat::IntRange::IntRange	utils/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange	access:public	signature:(int b, int e)
Minisat::IntRange::begin	utils/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange	access:public
Minisat::IntRange::end	utils/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange	access:public
Minisat::LessThan_default	mtl/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
Minisat::LessThan_default::operator ()	mtl/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default	access:public	signature:(T x, T y)
Minisat::Lit	core/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
Minisat::Lit::mkLit	core/SolverTypes.h	/^    friend Lit mkLit(Var var, bool sign = false);$/;"	p	struct:Minisat::Lit	access:friend	signature:(Var var, bool sign = false)
Minisat::Lit::operator !=	core/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
Minisat::Lit::operator <	core/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
Minisat::Lit::operator ==	core/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
Minisat::Lit::x	core/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit	access:public
Minisat::Map	mtl/Map.h	/^class Map {$/;"	c	namespace:Minisat
Minisat::Map::Map	mtl/Map.h	/^                   Map        (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map	access:private	signature:(Map<K,D,H,E>& other)
Minisat::Map::Map	mtl/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map	access:public	signature:()
Minisat::Map::Map	mtl/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map	access:public	signature:(const H& h, const E& e)
Minisat::Map::Pair	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map	access:public
Minisat::Map::Pair::data	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	access:public
Minisat::Map::Pair::key	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	access:public
Minisat::Map::_insert	mtl/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map	access:private	signature:(const K& k, const D& d)
Minisat::Map::bucket	mtl/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map	access:public	signature:(int i) const
Minisat::Map::bucket_count	mtl/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map	access:public	signature:() const
Minisat::Map::cap	mtl/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map	access:private
Minisat::Map::checkCap	mtl/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map	access:private	signature:(int new_size) const
Minisat::Map::clear	mtl/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map	access:public	signature:()
Minisat::Map::elems	mtl/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map	access:public	signature:() const
Minisat::Map::equals	mtl/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map	access:private
Minisat::Map::has	mtl/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k) const
Minisat::Map::hash	mtl/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map	access:private
Minisat::Map::index	mtl/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map	access:private	signature:(const K& k) const
Minisat::Map::insert	mtl/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Minisat::Map	access:public	signature:(const K& k, const D& d)
Minisat::Map::moveTo	mtl/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map	access:public	signature:(Map& other)
Minisat::Map::operator =	mtl/Map.h	/^    Map<K,D,H,E>&  operator = (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map	access:private	signature:(Map<K,D,H,E>& other)
Minisat::Map::operator []	mtl/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map	access:public	signature:(const K& k)
Minisat::Map::operator []	mtl/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map	access:public	signature:(const K& k) const
Minisat::Map::peek	mtl/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k, D& d) const
Minisat::Map::rehash	mtl/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map	access:private	signature:()
Minisat::Map::remove	mtl/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k)
Minisat::Map::size	mtl/Map.h	/^    int        size;$/;"	m	class:Minisat::Map	access:private
Minisat::Map::table	mtl/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map	access:private
Minisat::Map::~Map	mtl/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map	access:public	signature:()
Minisat::OccLists	core/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
Minisat::OccLists::OccLists	core/SolverTypes.h	/^    OccLists(const Deleted& d) : deleted(d) {}$/;"	f	class:Minisat::OccLists	access:public	signature:(const Deleted& d)
Minisat::OccLists::clean	core/SolverTypes.h	/^    void  clean     (const Idx& idx);$/;"	p	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
Minisat::OccLists::clean	core/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)$/;"	f	class:Minisat::OccLists	signature:(const Idx& idx)
Minisat::OccLists::cleanAll	core/SolverTypes.h	/^    void  cleanAll  ();$/;"	p	class:Minisat::OccLists	access:public	signature:()
Minisat::OccLists::cleanAll	core/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::cleanAll()$/;"	f	class:Minisat::OccLists	signature:()
Minisat::OccLists::clear	core/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists	access:public	signature:(bool free = true)
Minisat::OccLists::deleted	core/SolverTypes.h	/^    Deleted   deleted;$/;"	m	class:Minisat::OccLists	access:private
Minisat::OccLists::dirties	core/SolverTypes.h	/^    vec<Idx>  dirties;$/;"	m	class:Minisat::OccLists	access:private
Minisat::OccLists::dirty	core/SolverTypes.h	/^    vec<char> dirty;$/;"	m	class:Minisat::OccLists	access:private
Minisat::OccLists::init	core/SolverTypes.h	/^    void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
Minisat::OccLists::lookup	core/SolverTypes.h	/^    Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
Minisat::OccLists::occs	core/SolverTypes.h	/^    vec<Vec>  occs;$/;"	m	class:Minisat::OccLists	access:private
Minisat::OccLists::operator []	core/SolverTypes.h	/^    Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
Minisat::OccLists::smudge	core/SolverTypes.h	/^    void  smudge    (const Idx& idx){$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
Minisat::Option	utils/Options.h	/^class Option$/;"	c	namespace:Minisat
Minisat::Option::Option	utils/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option	access:protected	signature:(const char* name_, const char* desc_, const char* cate_, const char* type_)
Minisat::Option::OptionLt	utils/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option	access:protected
Minisat::Option::OptionLt::operator ()	utils/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt	access:public	signature:(const Option* x, const Option* y)
Minisat::Option::category	utils/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option	access:protected
Minisat::Option::description	utils/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option	access:protected
Minisat::Option::getHelpPrefixString	utils/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Minisat::Option	access:protected	signature:()
Minisat::Option::getOptionList	utils/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option	access:protected	signature:()
Minisat::Option::getUsageString	utils/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option	access:protected	signature:()
Minisat::Option::help	utils/Options.h	/^    virtual void help              (bool verbose = false) = 0;$/;"	p	class:Minisat::Option	access:public	signature:(bool verbose = false)
Minisat::Option::name	utils/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option	access:protected
Minisat::Option::parse	utils/Options.h	/^    virtual bool parse             (const char* str)      = 0;$/;"	p	class:Minisat::Option	access:public	signature:(const char* str)
Minisat::Option::parseOptions	utils/Options.h	/^    friend  void parseOptions      (int& argc, char** argv, bool strict);$/;"	p	class:Minisat::Option	access:friend	signature:(int& argc, char** argv, bool strict)
Minisat::Option::printUsageAndExit	utils/Options.h	/^    friend  void printUsageAndExit (int  argc, char** argv, bool verbose);$/;"	p	class:Minisat::Option	access:friend	signature:(int argc, char** argv, bool verbose)
Minisat::Option::setHelpPrefixStr	utils/Options.h	/^    friend  void setHelpPrefixStr  (const char* str);$/;"	p	class:Minisat::Option	access:friend	signature:(const char* str)
Minisat::Option::setUsageHelp	utils/Options.h	/^    friend  void setUsageHelp      (const char* str);$/;"	p	class:Minisat::Option	access:friend	signature:(const char* str)
Minisat::Option::type_name	utils/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option	access:protected
Minisat::Option::~Option	utils/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option	access:public	signature:()
Minisat::OutOfMemoryException	mtl/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
Minisat::Queue	mtl/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
Minisat::Queue::Key	mtl/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue	access:public
Minisat::Queue::Queue	mtl/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue	access:public	signature:()
Minisat::Queue::buf	mtl/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue	access:private
Minisat::Queue::clear	mtl/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue	access:public	signature:(bool dealloc = false)
Minisat::Queue::end	mtl/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue	access:private
Minisat::Queue::first	mtl/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue	access:private
Minisat::Queue::insert	mtl/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue	access:public	signature:(T elem)
Minisat::Queue::operator []	mtl/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue	access:public	signature:(int index)
Minisat::Queue::operator []	mtl/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue	access:public	signature:(int index) const
Minisat::Queue::peek	mtl/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue	access:public	signature:() const
Minisat::Queue::pop	mtl/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue	access:public	signature:()
Minisat::Queue::size	mtl/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue	access:public	signature:() const
Minisat::RegionAllocator	mtl/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
Minisat::RegionAllocator::Ref	mtl/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator	access:public
Minisat::RegionAllocator::Ref_Undef	mtl/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon1
Minisat::RegionAllocator::RegionAllocator	mtl/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(uint32_t start_cap = 1024*1024)
Minisat::RegionAllocator::Unit_Size	mtl/Alloc.h	/^    enum { Unit_Size = sizeof(uint32_t) };$/;"	e	enum:Minisat::RegionAllocator::__anon2
Minisat::RegionAllocator::ael	mtl/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(const T* t)
Minisat::RegionAllocator::alloc	mtl/Alloc.h	/^    Ref      alloc     (int size); $/;"	p	class:Minisat::RegionAllocator	access:public	signature:(int size)
Minisat::RegionAllocator::alloc	mtl/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator	signature:(int size)
Minisat::RegionAllocator::cap	mtl/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator	access:private
Minisat::RegionAllocator::capacity	mtl/Alloc.h	/^    void capacity(uint32_t min_cap);$/;"	p	class:Minisat::RegionAllocator	access:private	signature:(uint32_t min_cap)
Minisat::RegionAllocator::capacity	mtl/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator	signature:(uint32_t min_cap)
Minisat::RegionAllocator::free	mtl/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(int size)
Minisat::RegionAllocator::lea	mtl/Alloc.h	/^    T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r)
Minisat::RegionAllocator::lea	mtl/Alloc.h	/^    const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r) const
Minisat::RegionAllocator::memory	mtl/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator	access:private
Minisat::RegionAllocator::moveTo	mtl/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(RegionAllocator& to)
Minisat::RegionAllocator::operator []	mtl/Alloc.h	/^    T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r)
Minisat::RegionAllocator::operator []	mtl/Alloc.h	/^    const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r) const
Minisat::RegionAllocator::size	mtl/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:() const
Minisat::RegionAllocator::sz	mtl/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator	access:private
Minisat::RegionAllocator::wasted	mtl/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:() const
Minisat::RegionAllocator::wasted_	mtl/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator	access:private
Minisat::RegionAllocator::~RegionAllocator	mtl/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator	access:public	signature:()
Minisat::SimpSolver	simp/SimpSolver.h	/^class SimpSolver : public Solver {$/;"	c	namespace:Minisat	inherits:Solver
Minisat::SimpSolver::ClauseDeleted	simp/SimpSolver.h	/^    struct ClauseDeleted {$/;"	s	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::ClauseDeleted::ClauseDeleted	simp/SimpSolver.h	/^        explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted	access:public	signature:(const ClauseAllocator& _ca)
Minisat::SimpSolver::ClauseDeleted::ca	simp/SimpSolver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::SimpSolver::ClauseDeleted	access:public
Minisat::SimpSolver::ClauseDeleted::operator ()	simp/SimpSolver.h	/^        bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted	access:public	signature:(const CRef& cr) const
Minisat::SimpSolver::ElimLt	simp/SimpSolver.h	/^    struct ElimLt {$/;"	s	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::ElimLt::ElimLt	simp/SimpSolver.h	/^        explicit ElimLt(const vec<int>& no) : n_occ(no) {}$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(const vec<int>& no)
Minisat::SimpSolver::ElimLt::cost	simp/SimpSolver.h	/^        uint64_t cost  (Var x)        const { return (uint64_t)n_occ[toInt(mkLit(x))] * (uint64_t)n_occ[toInt(~mkLit(x))]; }$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(Var x) const
Minisat::SimpSolver::ElimLt::n_occ	simp/SimpSolver.h	/^        const vec<int>& n_occ;$/;"	m	struct:Minisat::SimpSolver::ElimLt	access:public
Minisat::SimpSolver::ElimLt::operator ()	simp/SimpSolver.h	/^        bool operator()(Var x, Var y) const { return cost(x) < cost(y); }$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(Var x, Var y) const
Minisat::SimpSolver::SimpSolver	simp/SimpSolver.h	/^    SimpSolver();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p);               \/\/ Add a unit clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p, Lit q);        \/\/ Add a binary clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p, Lit q, Lit r); \/\/ Add a ternary clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, Lit r)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^    bool    addClause (const vec<Lit>& ps);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& ps)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, Lit r)
Minisat::SimpSolver::addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& ps)
Minisat::SimpSolver::addClause_	simp/SimpSolver.h	/^    bool    addClause_(      vec<Lit>& ps);$/;"	p	class:Minisat::SimpSolver	access:public	signature:( vec<Lit>& ps)
Minisat::SimpSolver::addEmptyClause	simp/SimpSolver.h	/^    bool    addEmptyClause();                \/\/ Add the empty clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
Minisat::SimpSolver::addEmptyClause	simp/SimpSolver.h	/^inline bool SimpSolver::addEmptyClause()                     { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:()
Minisat::SimpSolver::asymm	simp/SimpSolver.h	/^    bool          asymm                    (Var v, CRef cr);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v, CRef cr)
Minisat::SimpSolver::asymmVar	simp/SimpSolver.h	/^    bool          asymmVar                 (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
Minisat::SimpSolver::asymm_lits	simp/SimpSolver.h	/^    int     asymm_lits;$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::backwardSubsumptionCheck	simp/SimpSolver.h	/^    bool          backwardSubsumptionCheck (bool verbose = false);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(bool verbose = false)
Minisat::SimpSolver::bwdsub_assigns	simp/SimpSolver.h	/^    int                 bwdsub_assigns;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::bwdsub_tmpunit	simp/SimpSolver.h	/^    CRef                bwdsub_tmpunit;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::clause_lim	simp/SimpSolver.h	/^    int     clause_lim;        \/\/ Variables are not eliminated if it produces a resolvent with a length above this limit.$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::cleanUpClauses	simp/SimpSolver.h	/^    void          cleanUpClauses           ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
Minisat::SimpSolver::elim_heap	simp/SimpSolver.h	/^    Heap<ElimLt>        elim_heap;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::elimclauses	simp/SimpSolver.h	/^    vec<uint32_t>       elimclauses;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::eliminate	simp/SimpSolver.h	/^    bool    eliminate   (bool turn_off_elim = false);  \/\/ Perform variable elimination based simplification. $/;"	p	class:Minisat::SimpSolver	access:public	signature:(bool turn_off_elim = false)
Minisat::SimpSolver::eliminateVar	simp/SimpSolver.h	/^    bool          eliminateVar             (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
Minisat::SimpSolver::eliminated	simp/SimpSolver.h	/^    vec<char>           eliminated;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::eliminated_vars	simp/SimpSolver.h	/^    int     eliminated_vars;$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::elimorder	simp/SimpSolver.h	/^    int                 elimorder;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::extendModel	simp/SimpSolver.h	/^    void          extendModel              ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
Minisat::SimpSolver::frozen	simp/SimpSolver.h	/^    vec<char>           frozen;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::garbageCollect	simp/SimpSolver.h	/^    virtual void garbageCollect();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
Minisat::SimpSolver::gatherTouchedClauses	simp/SimpSolver.h	/^    void          gatherTouchedClauses     ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
Minisat::SimpSolver::grow	simp/SimpSolver.h	/^    int     grow;              \/\/ Allow a variable elimination step to grow by a number of clauses (default to zero).$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::implied	simp/SimpSolver.h	/^    bool          implied                  (const vec<Lit>& c);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const vec<Lit>& c)
Minisat::SimpSolver::isEliminated	simp/SimpSolver.h	/^    bool    isEliminated(Var v) const;$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v) const
Minisat::SimpSolver::isEliminated	simp/SimpSolver.h	/^inline bool SimpSolver::isEliminated (Var v) const { return eliminated[v]; }$/;"	f	class:Minisat::SimpSolver	signature:(Var v) const
Minisat::SimpSolver::merge	simp/SimpSolver.h	/^    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, int& size);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const Clause& _ps, const Clause& _qs, Var v, int& size)
Minisat::SimpSolver::merge	simp/SimpSolver.h	/^    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
Minisat::SimpSolver::merges	simp/SimpSolver.h	/^    int     merges;$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::n_occ	simp/SimpSolver.h	/^    vec<int>            n_occ;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::n_touched	simp/SimpSolver.h	/^    int                 n_touched;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::newVar	simp/SimpSolver.h	/^    Var     newVar    (bool polarity = true, bool dvar = true);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(bool polarity = true, bool dvar = true)
Minisat::SimpSolver::occurs	simp/SimpSolver.h	/^                        occurs;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::relocAll	simp/SimpSolver.h	/^    void          relocAll                 (ClauseAllocator& to);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(ClauseAllocator& to)
Minisat::SimpSolver::removeClause	simp/SimpSolver.h	/^    void          removeClause             (CRef cr);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(CRef cr)
Minisat::SimpSolver::setFrozen	simp/SimpSolver.h	/^    void    setFrozen (Var v, bool b); \/\/ If a variable is frozen it will not be eliminated.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v, bool b)
Minisat::SimpSolver::setFrozen	simp/SimpSolver.h	/^inline void SimpSolver::setFrozen    (Var v, bool b) { frozen[v] = (char)b; if (use_simplification && !b) { updateElimHeap(v); } }$/;"	f	class:Minisat::SimpSolver	signature:(Var v, bool b)
Minisat::SimpSolver::simp_garbage_frac	simp/SimpSolver.h	/^    double  simp_garbage_frac; \/\/ A different limit for when to issue a GC during simplification (Also see 'garbage_frac').$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^    bool    solve       (                     bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:( bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^    bool    solve       (Lit p       ,        bool do_simp = true, bool turn_off_simp = false);       $/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p , bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^    bool    solve       (Lit p, Lit q,        bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^    bool    solve       (Lit p, Lit q, Lit r, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, Lit r, bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^    bool    solve       (const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (                     bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:( bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p       ,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p , bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& assumps, bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solveLimited	simp/SimpSolver.h	/^    lbool   solveLimited(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::solveLimited	simp/SimpSolver.h	/^inline lbool SimpSolver::solveLimited (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& assumps, bool do_simp, bool turn_off_simp)
Minisat::SimpSolver::solve_	simp/SimpSolver.h	/^    lbool         solve_                   (bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(bool do_simp = true, bool turn_off_simp = false)
Minisat::SimpSolver::strengthenClause	simp/SimpSolver.h	/^    bool          strengthenClause         (CRef cr, Lit l);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(CRef cr, Lit l)
Minisat::SimpSolver::substitute	simp/SimpSolver.h	/^    bool    substitute(Var v, Lit x);  \/\/ Replace all occurences of v with x (may cause a contradiction).$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v, Lit x)
Minisat::SimpSolver::subsumption_lim	simp/SimpSolver.h	/^    int     subsumption_lim;   \/\/ Do not check if subsumption against a clause larger than this. -1 means no limit.$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::subsumption_queue	simp/SimpSolver.h	/^    Queue<CRef>         subsumption_queue;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::touched	simp/SimpSolver.h	/^    vec<char>           touched;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::updateElimHeap	simp/SimpSolver.h	/^    void          updateElimHeap           (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
Minisat::SimpSolver::updateElimHeap	simp/SimpSolver.h	/^inline void SimpSolver::updateElimHeap(Var v) {$/;"	f	class:Minisat::SimpSolver	signature:(Var v)
Minisat::SimpSolver::use_asymm	simp/SimpSolver.h	/^    bool    use_asymm;         \/\/ Shrink clauses by asymmetric branching.$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::use_elim	simp/SimpSolver.h	/^    bool    use_elim;          \/\/ Perform variable elimination.$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::use_rcheck	simp/SimpSolver.h	/^    bool    use_rcheck;        \/\/ Check if a clause is already implied. Prett costly, and subsumes subsumptions :)$/;"	m	class:Minisat::SimpSolver	access:public
Minisat::SimpSolver::use_simplification	simp/SimpSolver.h	/^    bool                use_simplification;$/;"	m	class:Minisat::SimpSolver	access:protected
Minisat::SimpSolver::~SimpSolver	simp/SimpSolver.h	/^    ~SimpSolver();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
Minisat::Solver	core/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
Minisat::Solver::Solver	core/Solver.h	/^    Solver();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::VarOrderLt	core/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver	access:protected
Minisat::Solver::VarOrderLt::VarOrderLt	core/Solver.h	/^        VarOrderLt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt	access:public	signature:(const vec<double>& act)
Minisat::Solver::VarOrderLt::activity	core/Solver.h	/^        const vec<double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt	access:public
Minisat::Solver::VarOrderLt::operator ()	core/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt	access:public	signature:(Var x, Var y) const
Minisat::Solver::Watcher	core/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver	access:protected
Minisat::Solver::Watcher::Watcher	core/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(CRef cr, Lit p)
Minisat::Solver::Watcher::blocker	core/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher	access:public
Minisat::Solver::Watcher::cref	core/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher	access:public
Minisat::Solver::Watcher::operator !=	core/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(const Watcher& w) const
Minisat::Solver::Watcher::operator ==	core/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(const Watcher& w) const
Minisat::Solver::WatcherDeleted	core/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver	access:protected
Minisat::Solver::WatcherDeleted::WatcherDeleted	core/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted	access:public	signature:(const ClauseAllocator& _ca)
Minisat::Solver::WatcherDeleted::ca	core/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted	access:public
Minisat::Solver::WatcherDeleted::operator ()	core/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted	access:public	signature:(const Watcher& w) const
Minisat::Solver::abstractLevel	core/Solver.h	/^    uint32_t abstractLevel    (Var x) const; \/\/ Used to represent an abstraction of sets of decision levels.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
Minisat::Solver::abstractLevel	core/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver	signature:(Var x) const
Minisat::Solver::activity	core/Solver.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::addClause	core/Solver.h	/^    bool    addClause (Lit p);                                  \/\/ Add a unit clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p)
Minisat::Solver::addClause	core/Solver.h	/^    bool    addClause (Lit p, Lit q);                           \/\/ Add a binary clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q)
Minisat::Solver::addClause	core/Solver.h	/^    bool    addClause (Lit p, Lit q, Lit r);                    \/\/ Add a ternary clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q, Lit r)
Minisat::Solver::addClause	core/Solver.h	/^    bool    addClause (const vec<Lit>& ps);                     \/\/ Add a clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& ps)
Minisat::Solver::addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p)
Minisat::Solver::addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q)
Minisat::Solver::addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q, Lit r)
Minisat::Solver::addClause	core/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& ps)
Minisat::Solver::addClause_	core/Solver.h	/^    bool    addClause_(      vec<Lit>& ps);                     \/\/ Add a clause to the solver without making superflous internal copy. Will$/;"	p	class:Minisat::Solver	access:public	signature:( vec<Lit>& ps)
Minisat::Solver::addEmptyClause	core/Solver.h	/^    bool    addEmptyClause();                                   \/\/ Add the empty clause, making the solver contradictory.$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::addEmptyClause	core/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::addLearnt	core/Solver.h	/^    CRef 		addLearnt			(vec<Lit>& , float );		\/\/ Agrega una clusula a la base de datos de learnts$/;"	p	class:Minisat::Solver	access:public	signature:(vec<Lit>& , float )
Minisat::Solver::addLearnt	core/Solver.h	/^    CRef 		addLearnt			(vec<Lit>& , float , uint32_t );		\/\/ Agrega una clusula a la base de datos de learnts$/;"	p	class:Minisat::Solver	access:public	signature:(vec<Lit>& , float , uint32_t )
Minisat::Solver::add_tmp	core/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::analyze	core/Solver.h	/^    void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel);    \/\/ (bt = backtrack)$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
Minisat::Solver::analyzeFinal	core/Solver.h	/^    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         \/\/ COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, vec<Lit>& out_conflict)
Minisat::Solver::analyze_stack	core/Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::analyze_toclear	core/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::assigns	core/Solver.h	/^    vec<lbool>          assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::assumptions	core/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::asynch_interrupt	core/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::attachClause	core/Solver.h	/^    void     attachClause     (CRef cr);               \/\/ Attach a clause to watcher lists.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr)
Minisat::Solver::budgetOff	core/Solver.h	/^    void    budgetOff();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::budgetOff	core/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::ca	core/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::cancelUntil	core/Solver.h	/^    void     cancelUntil      (int level);                                             \/\/ Backtrack until a certain level.$/;"	p	class:Minisat::Solver	access:protected	signature:(int level)
Minisat::Solver::ccmin_mode	core/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::checkGarbage	core/Solver.h	/^    void    checkGarbage();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::checkGarbage	core/Solver.h	/^    void    checkGarbage(double gf);$/;"	p	class:Minisat::Solver	access:public	signature:(double gf)
Minisat::Solver::checkGarbage	core/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver	signature:(double gf)
Minisat::Solver::checkGarbage	core/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver	signature:(void)
Minisat::Solver::claBumpActivity	core/Solver.h	/^    void     claBumpActivity  (Clause& c);             \/\/ Increase a clause with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Clause& c)
Minisat::Solver::claBumpActivity	core/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver	signature:(Clause& c)
Minisat::Solver::claDecayActivity	core/Solver.h	/^    void     claDecayActivity ();                      \/\/ Decay all clauses with the specified factor. Implemented by increasing the 'bump' value instead.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::claDecayActivity	core/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::cla_inc	core/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::clause_decay	core/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::clauses	core/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::clauses_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::clearInterrupt	core/Solver.h	/^    void    clearInterrupt();     \/\/ Clear interrupt indicator flag.$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::clearInterrupt	core/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::conflict	core/Solver.h	/^    vec<Lit>   conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::conflict_budget	core/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::conflicts	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::dec_vars	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::decision	core/Solver.h	/^    vec<char>           decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::decisionLevel	core/Solver.h	/^    int      decisionLevel    ()      const; \/\/ Gives the current decisionlevel.$/;"	p	class:Minisat::Solver	access:protected	signature:() const
Minisat::Solver::decisionLevel	core/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::decisions	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::detachClause	core/Solver.h	/^    void     detachClause     (CRef cr, bool strict = false); \/\/ Detach a clause to watcher lists.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr, bool strict = false)
Minisat::Solver::drand	core/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver	access:protected	signature:(double& seed)
Minisat::Solver::enqueue	core/Solver.h	/^    bool     enqueue          (Lit p, CRef from = CRef_Undef);                         \/\/ Test if fact 'p' contradicts current state, enqueue otherwise.$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, CRef from = CRef_Undef)
Minisat::Solver::enqueue	core/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Minisat::Solver	signature:(Lit p, CRef from)
Minisat::Solver::garbageCollect	core/Solver.h	/^    virtual void garbageCollect();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::garbage_frac	core/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::getLearnts	core/Solver.h	/^    vec<CRef> &	getLearnts			();								\/\/ Retorna las clusulas aprendidas$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::insertVarOrder	core/Solver.h	/^    void     insertVarOrder   (Var x);                                                 \/\/ Insert a variable in the decision order priority queue.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x)
Minisat::Solver::insertVarOrder	core/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver	signature:(Var x)
Minisat::Solver::interrupt	core/Solver.h	/^    void    interrupt();          \/\/ Trigger a (potentially asynchronous) interruption of the solver.$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::interrupt	core/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::irand	core/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver	access:protected	signature:(double& seed, int size)
Minisat::Solver::learntMode	core/Solver.h	/^	int			learntMode;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learntParam	core/Solver.h	/^	int			learntParam;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learnts	core/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::learnts_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learntsize_adjust_cnt	core/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::learntsize_adjust_confl	core/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::learntsize_adjust_inc	core/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learntsize_adjust_start_confl	core/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learntsize_factor	core/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::learntsize_inc	core/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::level	core/Solver.h	/^    int      level            (Var x) const;$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
Minisat::Solver::level	core/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
Minisat::Solver::litRedundant	core/Solver.h	/^    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       \/\/ (helper method for 'analyze()')$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, uint32_t abstract_levels)
Minisat::Solver::locked	core/Solver.h	/^    bool     locked           (const Clause& c) const; \/\/ Returns TRUE if a clause is a reason for some implication in the current state.$/;"	p	class:Minisat::Solver	access:protected	signature:(const Clause& c) const
Minisat::Solver::locked	core/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Minisat::Solver	signature:(const Clause& c) const
Minisat::Solver::luby_restart	core/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::max_learnts	core/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::max_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::mkVarData	core/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver	access:protected	signature:(CRef cr, int l)
Minisat::Solver::model	core/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::modelValue	core/Solver.h	/^    lbool   modelValue (Lit p) const;       \/\/ The value of a literal in the last model. The last call to solve must have been satisfiable.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p) const
Minisat::Solver::modelValue	core/Solver.h	/^    lbool   modelValue (Var x) const;       \/\/ The value of a variable in the last model. The last call to solve must have been satisfiable.$/;"	p	class:Minisat::Solver	access:public	signature:(Var x) const
Minisat::Solver::modelValue	core/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	signature:(Lit p) const
Minisat::Solver::modelValue	core/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
Minisat::Solver::nAssigns	core/Solver.h	/^    int     nAssigns   ()      const;       \/\/ The current number of assigned literals.$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::nAssigns	core/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::nClauses	core/Solver.h	/^    int     nClauses   ()      const;       \/\/ The current number of original clauses.$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::nClauses	core/Solver.h	/^inline int      Solver::nClauses      ()      const   { return clauses.size(); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::nFreeVars	core/Solver.h	/^    int     nFreeVars  ()      const;$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::nFreeVars	core/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::nLearnts	core/Solver.h	/^    int     nLearnts   ()      const;       \/\/ The current number of learnt clauses.$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::nLearnts	core/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return learnts.size(); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::nVars	core/Solver.h	/^    int     nVars      ()      const;       \/\/ The current number of variables.$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::nVars	core/Solver.h	/^inline int      Solver::nVars         ()      const   { return vardata.size(); }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::newDecisionLevel	core/Solver.h	/^    void     newDecisionLevel ();                                                      \/\/ Begins a new decision level.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::newDecisionLevel	core/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::newVar	core/Solver.h	/^    Var     newVar    (bool polarity = true, bool dvar = true); \/\/ Add a new variable with parameters specifying variable mode.$/;"	p	class:Minisat::Solver	access:public	signature:(bool polarity = true, bool dvar = true)
Minisat::Solver::ok	core/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::okay	core/Solver.h	/^    bool    okay         () const;                  \/\/ FALSE means solver is in a conflicting state$/;"	p	class:Minisat::Solver	access:public	signature:() const
Minisat::Solver::okay	core/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::order_heap	core/Solver.h	/^    Heap<VarOrderLt>    order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::phase_saving	core/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::pickBranchLit	core/Solver.h	/^    Lit      pickBranchLit    ();                                                      \/\/ Return the next decision variable.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::polarity	core/Solver.h	/^    vec<char>           polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::progressEstimate	core/Solver.h	/^    double   progressEstimate ()      const; \/\/ DELETE THIS ?? IT'S NOT VERY USEFUL ...$/;"	p	class:Minisat::Solver	access:protected	signature:() const
Minisat::Solver::progress_estimate	core/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::propagate	core/Solver.h	/^    CRef     propagate        ();                                                      \/\/ Perform unit propagation. Returns possibly conflicting clause.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::propagation_budget	core/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::propagations	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::qhead	core/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::random_seed	core/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::random_var_freq	core/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::reason	core/Solver.h	/^    CRef     reason           (Var x) const;$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
Minisat::Solver::reason	core/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
Minisat::Solver::rebuildOrderHeap	core/Solver.h	/^    void     rebuildOrderHeap ();$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::reduceDB	core/Solver.h	/^    void     reduceDB         ();                                                      \/\/ Reduce the set of learnt clauses.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::relocAll	core/Solver.h	/^    void     relocAll         (ClauseAllocator& to);$/;"	p	class:Minisat::Solver	access:protected	signature:(ClauseAllocator& to)
Minisat::Solver::removeClause	core/Solver.h	/^    void     removeClause     (CRef cr);               \/\/ Detach and free a clause.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr)
Minisat::Solver::removeSatisfied	core/Solver.h	/^    void     removeSatisfied  (vec<CRef>& cs);                                         \/\/ Shrink 'cs' to contain only non-satisfied clauses.$/;"	p	class:Minisat::Solver	access:protected	signature:(vec<CRef>& cs)
Minisat::Solver::remove_satisfied	core/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::restart_first	core/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::restart_inc	core/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::rnd_decisions	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::rnd_init_act	core/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::rnd_pol	core/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::satisfied	core/Solver.h	/^    bool     satisfied        (const Clause& c) const; \/\/ Returns TRUE if a clause is satisfied in the current state.$/;"	p	class:Minisat::Solver	access:protected	signature:(const Clause& c) const
Minisat::Solver::saveLearntClauses	core/Solver.h	/^    void 		saveLearntClauses	();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::search	core/Solver.h	/^    lbool    search           (int nof_conflicts);                                     \/\/ Search for a given number of conflicts.$/;"	p	class:Minisat::Solver	access:protected	signature:(int nof_conflicts)
Minisat::Solver::seen	core/Solver.h	/^    vec<char>           seen;$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::setConfBudget	core/Solver.h	/^    void    setConfBudget(int64_t x);$/;"	p	class:Minisat::Solver	access:public	signature:(int64_t x)
Minisat::Solver::setConfBudget	core/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver	signature:(int64_t x)
Minisat::Solver::setDecisionVar	core/Solver.h	/^    void    setDecisionVar (Var v, bool b); \/\/ Declare if a variable should be eligible for selection in the decision heuristic.$/;"	p	class:Minisat::Solver	access:public	signature:(Var v, bool b)
Minisat::Solver::setDecisionVar	core/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver	signature:(Var v, bool b)
Minisat::Solver::setPolarity	core/Solver.h	/^    void    setPolarity    (Var v, bool b); \/\/ Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.$/;"	p	class:Minisat::Solver	access:public	signature:(Var v, bool b)
Minisat::Solver::setPolarity	core/Solver.h	/^inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }$/;"	f	class:Minisat::Solver	signature:(Var v, bool b)
Minisat::Solver::setPropBudget	core/Solver.h	/^    void    setPropBudget(int64_t x);$/;"	p	class:Minisat::Solver	access:public	signature:(int64_t x)
Minisat::Solver::setPropBudget	core/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver	signature:(int64_t x)
Minisat::Solver::simpDB_assigns	core/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::simpDB_props	core/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::simplify	core/Solver.h	/^    bool    simplify     ();                        \/\/ Removes already satisfied clauses.$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::solve	core/Solver.h	/^    bool    solve        ();                        \/\/ Search without assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::Solver::solve	core/Solver.h	/^    bool    solve        (Lit p);                   \/\/ Search for a model that respects a single assumption.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p)
Minisat::Solver::solve	core/Solver.h	/^    bool    solve        (Lit p, Lit q);            \/\/ Search for a model that respects two assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q)
Minisat::Solver::solve	core/Solver.h	/^    bool    solve        (Lit p, Lit q, Lit r);     \/\/ Search for a model that respects three assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q, Lit r)
Minisat::Solver::solve	core/Solver.h	/^    bool    solve        (const vec<Lit>& assumps); \/\/ Search for a model that respects a given set of assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& assumps)
Minisat::Solver::solve	core/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p)
Minisat::Solver::solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q)
Minisat::Solver::solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q, Lit r)
Minisat::Solver::solve	core/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& assumps)
Minisat::Solver::solveLimited	core/Solver.h	/^    lbool   solveLimited (const vec<Lit>& assumps); \/\/ Search for a model that respects a given set of assumptions (With resource constraints).$/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& assumps)
Minisat::Solver::solveLimited	core/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& assumps)
Minisat::Solver::solve_	core/Solver.h	/^    lbool    solve_           ();                                                      \/\/ Main solve method (assumptions given in 'assumptions').$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::solves	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::starts	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (FILE* f, Clause& c, vec<Var>& map, Var& max);$/;"	p	class:Minisat::Solver	access:public	signature:(FILE* f, Clause& c, vec<Var>& map, Var& max)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (FILE* f, const vec<Lit>& assumps);            \/\/ Write CNF to file in DIMACS-format.$/;"	p	class:Minisat::Solver	access:public	signature:(FILE* f, const vec<Lit>& assumps)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (const char *file, const vec<Lit>& assumps);$/;"	p	class:Minisat::Solver	access:public	signature:(const char *file, const vec<Lit>& assumps)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p, Lit q);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p, Lit q)
Minisat::Solver::toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p, Lit q, Lit r);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p, Lit q, Lit r)
Minisat::Solver::toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file)
Minisat::Solver::toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p)
Minisat::Solver::toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p, Lit q)
Minisat::Solver::toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p, Lit q, Lit r)
Minisat::Solver::tot_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::trail	core/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::trail_lim	core/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::uncheckedEnqueue	core/Solver.h	/^    void     uncheckedEnqueue (Lit p, CRef from = CRef_Undef);                         \/\/ Enqueue a literal. Assumes value of literal is undefined.$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, CRef from = CRef_Undef)
Minisat::Solver::value	core/Solver.h	/^    lbool   value      (Lit p) const;       \/\/ The current value of a literal.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p) const
Minisat::Solver::value	core/Solver.h	/^    lbool   value      (Var x) const;       \/\/ The current value of a variable.$/;"	p	class:Minisat::Solver	access:public	signature:(Var x) const
Minisat::Solver::value	core/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	signature:(Lit p) const
Minisat::Solver::value	core/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
Minisat::Solver::varBumpActivity	core/Solver.h	/^    void     varBumpActivity  (Var v);                 \/\/ Increase a variable with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var v)
Minisat::Solver::varBumpActivity	core/Solver.h	/^    void     varBumpActivity  (Var v, double inc);     \/\/ Increase a variable with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var v, double inc)
Minisat::Solver::varBumpActivity	core/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver	signature:(Var v)
Minisat::Solver::varBumpActivity	core/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver	signature:(Var v, double inc)
Minisat::Solver::varDecayActivity	core/Solver.h	/^    void     varDecayActivity ();                      \/\/ Decay all variables with the specified factor. Implemented by increasing the 'bump' value instead.$/;"	p	class:Minisat::Solver	access:protected	signature:()
Minisat::Solver::varDecayActivity	core/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver	signature:()
Minisat::Solver::var_decay	core/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::var_inc	core/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::vardata	core/Solver.h	/^    vec<VarData>        vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::verbosity	core/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver	access:public
Minisat::Solver::watches	core/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Minisat::Solver	access:protected
Minisat::Solver::withinBudget	core/Solver.h	/^    bool     withinBudget     ()      const;$/;"	p	class:Minisat::Solver	access:protected	signature:() const
Minisat::Solver::withinBudget	core/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver	signature:() const
Minisat::Solver::~Solver	core/Solver.h	/^    virtual ~Solver();$/;"	p	class:Minisat::Solver	access:public	signature:()
Minisat::StreamBuffer	utils/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
Minisat::StreamBuffer::StreamBuffer	utils/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:(gzFile i)
Minisat::StreamBuffer::assureLookahead	utils/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:Minisat::StreamBuffer	access:private	signature:()
Minisat::StreamBuffer::buf	utils/ParseUtils.h	/^    unsigned char buf[buffer_size];$/;"	m	class:Minisat::StreamBuffer	access:private
Minisat::StreamBuffer::in	utils/ParseUtils.h	/^    gzFile        in;$/;"	m	class:Minisat::StreamBuffer	access:private
Minisat::StreamBuffer::operator *	utils/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:() const
Minisat::StreamBuffer::operator ++	utils/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:()
Minisat::StreamBuffer::pos	utils/ParseUtils.h	/^    int           pos;$/;"	m	class:Minisat::StreamBuffer	access:private
Minisat::StreamBuffer::position	utils/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:() const
Minisat::StreamBuffer::size	utils/ParseUtils.h	/^    int           size;$/;"	m	class:Minisat::StreamBuffer	access:private
Minisat::StringOption	utils/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat	inherits:Option
Minisat::StringOption::StringOption	utils/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption	access:public	signature:(const char* c, const char* n, const char* d, const char* def = NULL)
Minisat::StringOption::help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption	access:public	signature:(bool verbose = false)
Minisat::StringOption::operator =	utils/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption	access:public	signature:(const char* x)
Minisat::StringOption::operator const char*	utils/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption	access:public	signature:(void) const
Minisat::StringOption::operator const char*&	utils/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption	access:public	signature:(void)
Minisat::StringOption::parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption	access:public	signature:(const char* str)
Minisat::StringOption::value	utils/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption	access:private
Minisat::Var	core/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat
Minisat::VarData	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	s	namespace:Minisat
Minisat::VarData::level	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::VarData	access:public
Minisat::VarData::reason	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::VarData	access:public
Minisat::append	mtl/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat	signature:(const vec<T>& from, vec<T>& to)
Minisat::buffer_size	utils/ParseUtils.h	/^static const int buffer_size = 1048576;$/;"	m	namespace:Minisat
Minisat::copy	mtl/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat	signature:(const T& from, T& to)
Minisat::copy	mtl/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat	signature:(const vec<T>& from, vec<T>& to, bool append = false)
Minisat::cpuTime	utils/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat	signature:(void)
Minisat::cpuTime	utils/System.h	/^static inline double cpuTime(void); \/\/ CPU-time in seconds.$/;"	p	namespace:Minisat	signature:(void)
Minisat::eagerMatch	utils/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat	signature:(B& in, const char* str)
Minisat::find	mtl/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat	signature:(V& ts, const T& t)
Minisat::hash	mtl/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(int32_t x)
Minisat::hash	mtl/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(int64_t x)
Minisat::hash	mtl/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat	signature:(uint32_t x)
Minisat::hash	mtl/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(uint64_t x)
Minisat::isEof	utils/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat	signature:(StreamBuffer& in)
Minisat::isEof	utils/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat	signature:(const char* in)
Minisat::lbool	core/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
Minisat::lbool::lbool	core/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool	access:public	signature:(bool x)
Minisat::lbool::lbool	core/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool	access:public	signature:(uint8_t v)
Minisat::lbool::lbool	core/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool	access:public	signature:()
Minisat::lbool::operator !=	core/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
Minisat::lbool::operator &&	core/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
Minisat::lbool::operator ==	core/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
Minisat::lbool::operator ^	core/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool	access:public	signature:(bool b) const
Minisat::lbool::operator ||	core/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
Minisat::lbool::toInt	core/SolverTypes.h	/^    friend int   toInt  (lbool l);$/;"	p	class:Minisat::lbool	access:friend	signature:(lbool l)
Minisat::lbool::toLbool	core/SolverTypes.h	/^    friend lbool toLbool(int   v);$/;"	p	class:Minisat::lbool	access:friend	signature:(int v)
Minisat::lbool::value	core/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool	access:private
Minisat::lit_Error	core/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	m	namespace:Minisat
Minisat::lit_Undef	core/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	m	namespace:Minisat
Minisat::match	utils/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat	signature:(B& in, const char* str)
Minisat::memUsed	utils/System.cc	/^double Minisat::memUsed() { $/;"	f	class:Minisat	signature:()
Minisat::memUsed	utils/System.cc	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024); }$/;"	f	class:Minisat	signature:()
Minisat::memUsed	utils/System.cc	/^double Minisat::memUsed(void) {$/;"	f	class:Minisat	signature:(void)
Minisat::memUsed	utils/System.h	/^extern double memUsed();            \/\/ Memory in mega bytes (returns 0 for unsupported architectures).$/;"	p	namespace:Minisat	signature:()
Minisat::memUsedPeak	utils/System.cc	/^double Minisat::memUsedPeak() { $/;"	f	class:Minisat	signature:()
Minisat::memUsedPeak	utils/System.h	/^extern double memUsedPeak();        \/\/ Peak-memory in mega bytes (returns 0 for unsupported architectures).$/;"	p	namespace:Minisat	signature:()
Minisat::mkLit	core/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f	namespace:Minisat	signature:(Var var, bool sign)
Minisat::nprimes	mtl/Map.h	/^static const int nprimes          = 25;$/;"	m	namespace:Minisat
Minisat::operator ^	core/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat	signature:(Lit p, bool b)
Minisat::operator ~	core/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat	signature:(Lit p)
Minisat::parseFloat	utils/ParseUtils.h	/^static float parseFloat(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
Minisat::parseInt	utils/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
Minisat::parseOptions	utils/Options.cc	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat	signature:(int& argc, char** argv, bool strict)
Minisat::parseOptions	utils/Options.h	/^extern void parseOptions     (int& argc, char** argv, bool strict = false);$/;"	p	namespace:Minisat	signature:(int& argc, char** argv, bool strict = false)
Minisat::parse_DIMACS	core/Dimacs.h	/^static void parse_DIMACS(gzFile input_stream, Solver& S) {$/;"	f	namespace:Minisat	signature:(gzFile input_stream, Solver& S)
Minisat::parse_DIMACS_main	core/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S) {$/;"	f	namespace:Minisat	signature:(B& in, Solver& S)
Minisat::primes	mtl/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	m	namespace:Minisat
Minisat::printUsageAndExit	utils/Options.cc	/^void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)$/;"	f	class:Minisat	signature:(int argc, char** argv, bool verbose)
Minisat::printUsageAndExit	utils/Options.h	/^extern void printUsageAndExit(int  argc, char** argv, bool verbose = false);$/;"	p	namespace:Minisat	signature:(int argc, char** argv, bool verbose = false)
Minisat::readAllLearnt	core/Dimacs.h	/^static void readAllLearnt(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
Minisat::readClause	core/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f	namespace:Minisat	signature:(B& in, Solver& S, vec<Lit>& lits)
Minisat::readLearntClauses	core/Dimacs.h	/^static void readLearntClauses(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
Minisat::readLessActive	core/Dimacs.h	/^static void readLessActive(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
Minisat::readMoreActive	core/Dimacs.h	/^static void readMoreActive(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
Minisat::readSmallerThan	core/Dimacs.h	/^static void readSmallerThan(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
Minisat::remove	mtl/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat	signature:(V& ts, const T& t)
Minisat::selectionSort	mtl/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat	signature:(T* array, int size)
Minisat::selectionSort	mtl/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	signature:(T* array, int size, LessThan lt)
Minisat::setHelpPrefixStr	utils/Options.cc	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat	signature:(const char* str)
Minisat::setHelpPrefixStr	utils/Options.h	/^extern void setHelpPrefixStr (const char* str);$/;"	p	namespace:Minisat	signature:(const char* str)
Minisat::setUsageHelp	utils/Options.cc	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat	signature:(const char* str)
Minisat::setUsageHelp	utils/Options.h	/^extern void setUsageHelp     (const char* str);$/;"	p	namespace:Minisat	signature:(const char* str)
Minisat::sign	core/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat	signature:(Lit p)
Minisat::skipLine	utils/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
Minisat::skipWhitespace	utils/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
Minisat::sort	mtl/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat	signature:(vec<T>& v, LessThan lt)
Minisat::sort	mtl/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat	signature:(T* array, int size)
Minisat::sort	mtl/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat	signature:(vec<T>& v)
Minisat::sort	mtl/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	signature:(T* array, int size, LessThan lt)
Minisat::toInt	core/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat	signature:(Lit p)
Minisat::toInt	core/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat	signature:(Var v)
Minisat::toInt	core/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat	signature:(lbool l)
Minisat::toLbool	core/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat	signature:(int v)
Minisat::toLit	core/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat	signature:(int i)
Minisat::var	core/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat	signature:(Lit p)
Minisat::vec	mtl/Vec.h	/^class vec {$/;"	c	namespace:Minisat
Minisat::vec::cap	mtl/Vec.h	/^    int cap;$/;"	m	class:Minisat::vec	access:private
Minisat::vec::capacity	mtl/Vec.h	/^    int      capacity (void) const     { return cap; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
Minisat::vec::capacity	mtl/Vec.h	/^    void     capacity (int min_cap);$/;"	p	class:Minisat::vec	access:public	signature:(int min_cap)
Minisat::vec::capacity	mtl/Vec.h	/^void vec<T>::capacity(int min_cap) {$/;"	f	class:Minisat::vec	signature:(int min_cap)
Minisat::vec::clear	mtl/Vec.h	/^    void     clear    (bool dealloc = false);$/;"	p	class:Minisat::vec	access:public	signature:(bool dealloc = false)
Minisat::vec::clear	mtl/Vec.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:Minisat::vec	signature:(bool dealloc)
Minisat::vec::copyTo	mtl/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:Minisat::vec	access:public	signature:(vec<T>& copy) const
Minisat::vec::data	mtl/Vec.h	/^    T*  data;$/;"	m	class:Minisat::vec	access:private
Minisat::vec::growTo	mtl/Vec.h	/^    void     growTo   (int size);$/;"	p	class:Minisat::vec	access:public	signature:(int size)
Minisat::vec::growTo	mtl/Vec.h	/^    void     growTo   (int size, const T& pad);$/;"	p	class:Minisat::vec	access:public	signature:(int size, const T& pad)
Minisat::vec::growTo	mtl/Vec.h	/^void vec<T>::growTo(int size) {$/;"	f	class:Minisat::vec	signature:(int size)
Minisat::vec::growTo	mtl/Vec.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:Minisat::vec	signature:(int size, const T& pad)
Minisat::vec::imax	mtl/Vec.h	/^    static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }$/;"	f	class:Minisat::vec	access:private	signature:(int x, int y)
Minisat::vec::last	mtl/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
Minisat::vec::last	mtl/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
Minisat::vec::moveTo	mtl/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:Minisat::vec	access:public	signature:(vec<T>& dest)
Minisat::vec::nextCap	mtl/Vec.h	/^    static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }$/;"	f	class:Minisat::vec	access:private	signature:(int& cap)
Minisat::vec::operator =	mtl/Vec.h	/^    vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }$/;"	f	class:Minisat::vec	access:private	signature:(vec<T>& other)
Minisat::vec::operator T*	mtl/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
Minisat::vec::operator []	mtl/Vec.h	/^    T&       operator [] (int index)       { return data[index]; }$/;"	f	class:Minisat::vec	access:public	signature:(int index)
Minisat::vec::operator []	mtl/Vec.h	/^    const T& operator [] (int index) const { return data[index]; }$/;"	f	class:Minisat::vec	access:public	signature:(int index) const
Minisat::vec::pop	mtl/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec	access:public	signature:(void)
Minisat::vec::push	mtl/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }$/;"	f	class:Minisat::vec	access:public	signature:(const T& elem)
Minisat::vec::push	mtl/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
Minisat::vec::push_	mtl/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec	access:public	signature:(const T& elem)
Minisat::vec::shrink	mtl/Vec.h	/^    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec	access:public	signature:(int nelems)
Minisat::vec::shrink_	mtl/Vec.h	/^    void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec	access:public	signature:(int nelems)
Minisat::vec::size	mtl/Vec.h	/^    int      size     (void) const     { return sz; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
Minisat::vec::sz	mtl/Vec.h	/^    int sz;$/;"	m	class:Minisat::vec	access:private
Minisat::vec::vec	mtl/Vec.h	/^             vec        (vec<T>& other) { assert(0); }$/;"	f	class:Minisat::vec	access:private	signature:(vec<T>& other)
Minisat::vec::vec	mtl/Vec.h	/^    explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec	access:public	signature:(int size)
Minisat::vec::vec	mtl/Vec.h	/^    vec()                       : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:Minisat::vec	access:public	signature:()
Minisat::vec::vec	mtl/Vec.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec	access:public	signature:(int size, const T& pad)
Minisat::vec::~vec	mtl/Vec.h	/^   ~vec()                                                          { clear(true); }$/;"	f	class:Minisat::vec	access:public	signature:()
Minisat::xrealloc	mtl/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat	signature:(void *ptr, size_t size)
Minisat_Alg_h	mtl/Alg.h	22;"	d
Minisat_Alloc_h	mtl/Alloc.h	22;"	d
Minisat_Dimacs_h	core/Dimacs.h	22;"	d
Minisat_Heap_h	mtl/Heap.h	22;"	d
Minisat_IntTypes_h	mtl/IntTypes.h	21;"	d
Minisat_Map_h	mtl/Map.h	21;"	d
Minisat_Options_h	utils/Options.h	21;"	d
Minisat_ParseUtils_h	utils/ParseUtils.h	22;"	d
Minisat_Queue_h	mtl/Queue.h	22;"	d
Minisat_SimpSolver_h	simp/SimpSolver.h	22;"	d
Minisat_SolverTypes_h	core/SolverTypes.h	23;"	d
Minisat_Solver_h	core/Solver.h	22;"	d
Minisat_Sort_h	mtl/Sort.h	22;"	d
Minisat_System_h	utils/System.h	22;"	d
Minisat_Vec_h	mtl/Vec.h	22;"	d
Minisat_XAlloc_h	mtl/XAlloc.h	22;"	d
OccLists	core/SolverTypes.h	/^    OccLists(const Deleted& d) : deleted(d) {}$/;"	f	class:Minisat::OccLists	access:public	signature:(const Deleted& d)
OccLists	core/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
Option	utils/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option	access:protected	signature:(const char* name_, const char* desc_, const char* cate_, const char* type_)
Option	utils/Options.h	/^class Option$/;"	c	namespace:Minisat
OptionLt	utils/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option	access:protected
OutOfMemoryException	mtl/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
PCOBJS	mtl/template.mk	/^PCOBJS     = $(addsuffix p,  $(COBJS))$/;"	m
PWD	mtl/template.mk	/^PWD        = $(shell pwd)$/;"	m
Pair	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map	access:public
Queue	mtl/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue	access:public	signature:()
Queue	mtl/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
RCOBJS	mtl/template.mk	/^RCOBJS     = $(addsuffix r,  $(COBJS))$/;"	m
Ref	mtl/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator	access:public
Ref_Undef	mtl/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon1
RegionAllocator	mtl/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(uint32_t start_cap = 1024*1024)
RegionAllocator	mtl/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
SIGINT_exit	core/Main.cc	/^static void SIGINT_exit(int signum) {$/;"	f	file:	signature:(int signum)
SIGINT_exit	simp/Main.cc	/^static void SIGINT_exit(int signum) {$/;"	f	file:	signature:(int signum)
SIGINT_interrupt	core/Main.cc	/^static void SIGINT_interrupt(int signum) { $/;"	f	file:	signature:(int signum)
SIGINT_interrupt	simp/Main.cc	/^static void SIGINT_interrupt(int signum) { solver->interrupt(); }$/;"	f	file:	signature:(int signum)
SimpSolver	simp/SimpSolver.cc	/^SimpSolver::SimpSolver() :$/;"	f	class:SimpSolver	signature:()
SimpSolver	simp/SimpSolver.h	/^    SimpSolver();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
SimpSolver	simp/SimpSolver.h	/^class SimpSolver : public Solver {$/;"	c	namespace:Minisat	inherits:Solver
SimpSolver::SimpSolver	simp/SimpSolver.cc	/^SimpSolver::SimpSolver() :$/;"	f	class:SimpSolver	signature:()
SimpSolver::addClause_	simp/SimpSolver.cc	/^bool SimpSolver::addClause_(vec<Lit>& ps)$/;"	f	class:SimpSolver	signature:(vec<Lit>& ps)
SimpSolver::asymm	simp/SimpSolver.cc	/^bool SimpSolver::asymm(Var v, CRef cr)$/;"	f	class:SimpSolver	signature:(Var v, CRef cr)
SimpSolver::asymmVar	simp/SimpSolver.cc	/^bool SimpSolver::asymmVar(Var v)$/;"	f	class:SimpSolver	signature:(Var v)
SimpSolver::backwardSubsumptionCheck	simp/SimpSolver.cc	/^bool SimpSolver::backwardSubsumptionCheck(bool verbose)$/;"	f	class:SimpSolver	signature:(bool verbose)
SimpSolver::cleanUpClauses	simp/SimpSolver.cc	/^void SimpSolver::cleanUpClauses()$/;"	f	class:SimpSolver	signature:()
SimpSolver::eliminate	simp/SimpSolver.cc	/^bool SimpSolver::eliminate(bool turn_off_elim)$/;"	f	class:SimpSolver	signature:(bool turn_off_elim)
SimpSolver::eliminateVar	simp/SimpSolver.cc	/^bool SimpSolver::eliminateVar(Var v)$/;"	f	class:SimpSolver	signature:(Var v)
SimpSolver::extendModel	simp/SimpSolver.cc	/^void SimpSolver::extendModel()$/;"	f	class:SimpSolver	signature:()
SimpSolver::garbageCollect	simp/SimpSolver.cc	/^void SimpSolver::garbageCollect()$/;"	f	class:SimpSolver	signature:()
SimpSolver::gatherTouchedClauses	simp/SimpSolver.cc	/^void SimpSolver::gatherTouchedClauses()$/;"	f	class:SimpSolver	signature:()
SimpSolver::implied	simp/SimpSolver.cc	/^bool SimpSolver::implied(const vec<Lit>& c)$/;"	f	class:SimpSolver	signature:(const vec<Lit>& c)
SimpSolver::merge	simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)$/;"	f	class:SimpSolver	signature:(const Clause& _ps, const Clause& _qs, Var v, int& size)
SimpSolver::merge	simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)$/;"	f	class:SimpSolver	signature:(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
SimpSolver::newVar	simp/SimpSolver.cc	/^Var SimpSolver::newVar(bool sign, bool dvar) {$/;"	f	class:SimpSolver	signature:(bool sign, bool dvar)
SimpSolver::relocAll	simp/SimpSolver.cc	/^void SimpSolver::relocAll(ClauseAllocator& to)$/;"	f	class:SimpSolver	signature:(ClauseAllocator& to)
SimpSolver::removeClause	simp/SimpSolver.cc	/^void SimpSolver::removeClause(CRef cr)$/;"	f	class:SimpSolver	signature:(CRef cr)
SimpSolver::solve_	simp/SimpSolver.cc	/^lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)$/;"	f	class:SimpSolver	signature:(bool do_simp, bool turn_off_simp)
SimpSolver::strengthenClause	simp/SimpSolver.cc	/^bool SimpSolver::strengthenClause(CRef cr, Lit l)$/;"	f	class:SimpSolver	signature:(CRef cr, Lit l)
SimpSolver::substitute	simp/SimpSolver.cc	/^bool SimpSolver::substitute(Var v, Lit x)$/;"	f	class:SimpSolver	signature:(Var v, Lit x)
SimpSolver::~SimpSolver	simp/SimpSolver.cc	/^SimpSolver::~SimpSolver()$/;"	f	class:SimpSolver	signature:()
Solver	core/Solver.cc	/^Solver::Solver() :$/;"	f	class:Solver	signature:()
Solver	core/Solver.h	/^    Solver();$/;"	p	class:Minisat::Solver	access:public	signature:()
Solver	core/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
Solver::Solver	core/Solver.cc	/^Solver::Solver() :$/;"	f	class:Solver	signature:()
Solver::addClause_	core/Solver.cc	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver	signature:(vec<Lit>& ps)
Solver::addLearnt	core/Solver.cc	/^CRef Solver::addLearnt(vec<Lit>& learnt_clause, float act = -1.0) $/;"	f	class:Solver	signature:(vec<Lit>& learnt_clause, float act = -1.0)
Solver::addLearnt	core/Solver.cc	/^CRef Solver::addLearnt(vec<Lit>& learnt_clause, float act = -1.0, uint32_t lbd = 0) $/;"	f	class:Solver	signature:(vec<Lit>& learnt_clause, float act = -1.0, uint32_t lbd = 0)
Solver::analyze	core/Solver.cc	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver	signature:(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
Solver::analyzeFinal	core/Solver.cc	/^void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)$/;"	f	class:Solver	signature:(Lit p, vec<Lit>& out_conflict)
Solver::attachClause	core/Solver.cc	/^void Solver::attachClause(CRef cr) {$/;"	f	class:Solver	signature:(CRef cr)
Solver::cancelUntil	core/Solver.cc	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver	signature:(int level)
Solver::detachClause	core/Solver.cc	/^void Solver::detachClause(CRef cr, bool strict) {$/;"	f	class:Solver	signature:(CRef cr, bool strict)
Solver::garbageCollect	core/Solver.cc	/^void Solver::garbageCollect()$/;"	f	class:Solver	signature:()
Solver::litRedundant	core/Solver.cc	/^bool Solver::litRedundant(Lit p, uint32_t abstract_levels)$/;"	f	class:Solver	signature:(Lit p, uint32_t abstract_levels)
Solver::newVar	core/Solver.cc	/^Var Solver::newVar(bool sign, bool dvar)$/;"	f	class:Solver	signature:(bool sign, bool dvar)
Solver::pickBranchLit	core/Solver.cc	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver	signature:()
Solver::progressEstimate	core/Solver.cc	/^double Solver::progressEstimate() const$/;"	f	class:Solver	signature:() const
Solver::propagate	core/Solver.cc	/^CRef Solver::propagate()$/;"	f	class:Solver	signature:()
Solver::rebuildOrderHeap	core/Solver.cc	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver	signature:()
Solver::reduceDB	core/Solver.cc	/^void Solver::reduceDB()$/;"	f	class:Solver	signature:()
Solver::relocAll	core/Solver.cc	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver	signature:(ClauseAllocator& to)
Solver::removeClause	core/Solver.cc	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver	signature:(CRef cr)
Solver::removeSatisfied	core/Solver.cc	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver	signature:(vec<CRef>& cs)
Solver::satisfied	core/Solver.cc	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver	signature:(const Clause& c) const
Solver::saveLearntClauses	core/Solver.cc	/^void Solver::saveLearntClauses() {$/;"	f	class:Solver	signature:()
Solver::search	core/Solver.cc	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver	signature:(int nof_conflicts)
Solver::simplify	core/Solver.cc	/^bool Solver::simplify()$/;"	f	class:Solver	signature:()
Solver::solve_	core/Solver.cc	/^lbool Solver::solve_()$/;"	f	class:Solver	signature:()
Solver::toDimacs	core/Solver.cc	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver	signature:(FILE* f, Clause& c, vec<Var>& map, Var& max)
Solver::toDimacs	core/Solver.cc	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver	signature:(FILE* f, const vec<Lit>& assumps)
Solver::toDimacs	core/Solver.cc	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver	signature:(const char *file, const vec<Lit>& assumps)
Solver::uncheckedEnqueue	core/Solver.cc	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver	signature:(Lit p, CRef from)
Solver::~Solver	core/Solver.cc	/^Solver::~Solver()$/;"	f	class:Solver	signature:()
StreamBuffer	utils/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:(gzFile i)
StreamBuffer	utils/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
StringOption	utils/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption	access:public	signature:(const char* c, const char* n, const char* d, const char* def = NULL)
StringOption	utils/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat	inherits:Option
Unit_Size	mtl/Alloc.h	/^    enum { Unit_Size = sizeof(uint32_t) };$/;"	e	enum:Minisat::RegionAllocator::__anon2
Var	core/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat
VarData	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	s	namespace:Minisat
VarOrderLt	core/Solver.h	/^        VarOrderLt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt	access:public	signature:(const vec<double>& act)
VarOrderLt	core/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver	access:protected
Watcher	core/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(CRef cr, Lit p)
Watcher	core/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver	access:protected
WatcherDeleted	core/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted	access:public	signature:(const ClauseAllocator& _ca)
WatcherDeleted	core/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver	access:protected
_cat	core/Solver.cc	/^static const char* _cat = "CORE";$/;"	v	file:
_cat	simp/SimpSolver.cc	/^static const char* _cat = "SIMP";$/;"	v	file:
_insert	mtl/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map	access:private	signature:(const K& k, const D& d)
abs	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
abstractLevel	core/Solver.h	/^    uint32_t abstractLevel    (Var x) const; \/\/ Used to represent an abstraction of sets of decision levels.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
abstractLevel	core/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver	signature:(Var x) const
abstraction	core/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
act	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
activity	core/Solver.h	/^        const vec<double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt	access:public
activity	core/Solver.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Minisat::Solver	access:protected
activity	core/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Minisat::Clause	access:public	signature:()
addClause	core/Solver.h	/^    bool    addClause (Lit p);                                  \/\/ Add a unit clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p)
addClause	core/Solver.h	/^    bool    addClause (Lit p, Lit q);                           \/\/ Add a binary clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q)
addClause	core/Solver.h	/^    bool    addClause (Lit p, Lit q, Lit r);                    \/\/ Add a ternary clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q, Lit r)
addClause	core/Solver.h	/^    bool    addClause (const vec<Lit>& ps);                     \/\/ Add a clause to the solver. $/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& ps)
addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p)
addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q)
addClause	core/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q, Lit r)
addClause	core/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& ps)
addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p);               \/\/ Add a unit clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p)
addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p, Lit q);        \/\/ Add a binary clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q)
addClause	simp/SimpSolver.h	/^    bool    addClause (Lit p, Lit q, Lit r); \/\/ Add a ternary clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, Lit r)
addClause	simp/SimpSolver.h	/^    bool    addClause (const vec<Lit>& ps);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& ps)
addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p)
addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q)
addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, Lit r)
addClause	simp/SimpSolver.h	/^inline bool SimpSolver::addClause    (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& ps)
addClause_	core/Solver.cc	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver	signature:(vec<Lit>& ps)
addClause_	core/Solver.h	/^    bool    addClause_(      vec<Lit>& ps);                     \/\/ Add a clause to the solver without making superflous internal copy. Will$/;"	p	class:Minisat::Solver	access:public	signature:( vec<Lit>& ps)
addClause_	simp/SimpSolver.cc	/^bool SimpSolver::addClause_(vec<Lit>& ps)$/;"	f	class:SimpSolver	signature:(vec<Lit>& ps)
addClause_	simp/SimpSolver.h	/^    bool    addClause_(      vec<Lit>& ps);$/;"	p	class:Minisat::SimpSolver	access:public	signature:( vec<Lit>& ps)
addEmptyClause	core/Solver.h	/^    bool    addEmptyClause();                                   \/\/ Add the empty clause, making the solver contradictory.$/;"	p	class:Minisat::Solver	access:public	signature:()
addEmptyClause	core/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver	signature:()
addEmptyClause	simp/SimpSolver.h	/^    bool    addEmptyClause();                \/\/ Add the empty clause to the solver.$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
addEmptyClause	simp/SimpSolver.h	/^inline bool SimpSolver::addEmptyClause()                     { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::SimpSolver	signature:()
addLearnt	core/Solver.cc	/^CRef Solver::addLearnt(vec<Lit>& learnt_clause, float act = -1.0) $/;"	f	class:Solver	signature:(vec<Lit>& learnt_clause, float act = -1.0)
addLearnt	core/Solver.cc	/^CRef Solver::addLearnt(vec<Lit>& learnt_clause, float act = -1.0, uint32_t lbd = 0) $/;"	f	class:Solver	signature:(vec<Lit>& learnt_clause, float act = -1.0, uint32_t lbd = 0)
addLearnt	core/Solver.h	/^    CRef 		addLearnt			(vec<Lit>& , float );		\/\/ Agrega una clusula a la base de datos de learnts$/;"	p	class:Minisat::Solver	access:public	signature:(vec<Lit>& , float )
addLearnt	core/Solver.h	/^    CRef 		addLearnt			(vec<Lit>& , float , uint32_t );		\/\/ Agrega una clusula a la base de datos de learnts$/;"	p	class:Minisat::Solver	access:public	signature:(vec<Lit>& , float , uint32_t )
add_tmp	core/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver	access:protected
ael	core/SolverTypes.h	/^    Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(const Clause* t)
ael	mtl/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(const T* t)
alloc	core/SolverTypes.h	/^    CRef alloc(const Lits& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(const Lits& ps, bool learnt = false)
alloc	mtl/Alloc.h	/^    Ref      alloc     (int size); $/;"	p	class:Minisat::RegionAllocator	access:public	signature:(int size)
alloc	mtl/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator	signature:(int size)
analyze	core/Solver.cc	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver	signature:(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
analyze	core/Solver.h	/^    void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel);    \/\/ (bt = backtrack)$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
analyzeFinal	core/Solver.cc	/^void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)$/;"	f	class:Solver	signature:(Lit p, vec<Lit>& out_conflict)
analyzeFinal	core/Solver.h	/^    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         \/\/ COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, vec<Lit>& out_conflict)
analyze_stack	core/Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Minisat::Solver	access:protected
analyze_toclear	core/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver	access:protected
append	mtl/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat	signature:(const vec<T>& from, vec<T>& to)
assigns	core/Solver.h	/^    vec<lbool>          assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver	access:protected
assumptions	core/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Minisat::Solver	access:protected
assureLookahead	utils/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:Minisat::StreamBuffer	access:private	signature:()
asymm	simp/SimpSolver.cc	/^bool SimpSolver::asymm(Var v, CRef cr)$/;"	f	class:SimpSolver	signature:(Var v, CRef cr)
asymm	simp/SimpSolver.h	/^    bool          asymm                    (Var v, CRef cr);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v, CRef cr)
asymmVar	simp/SimpSolver.cc	/^bool SimpSolver::asymmVar(Var v)$/;"	f	class:SimpSolver	signature:(Var v)
asymmVar	simp/SimpSolver.h	/^    bool          asymmVar                 (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
asymm_lits	simp/SimpSolver.h	/^    int     asymm_lits;$/;"	m	class:Minisat::SimpSolver	access:public
asynch_interrupt	core/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver	access:protected
attachClause	core/Solver.cc	/^void Solver::attachClause(CRef cr) {$/;"	f	class:Solver	signature:(CRef cr)
attachClause	core/Solver.h	/^    void     attachClause     (CRef cr);               \/\/ Attach a clause to watcher lists.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr)
backwardSubsumptionCheck	simp/SimpSolver.cc	/^bool SimpSolver::backwardSubsumptionCheck(bool verbose)$/;"	f	class:SimpSolver	signature:(bool verbose)
backwardSubsumptionCheck	simp/SimpSolver.h	/^    bool          backwardSubsumptionCheck (bool verbose = false);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(bool verbose = false)
begin	utils/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange	access:public
begin	utils/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange	access:public
begin	utils/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range	access:public
begin_inclusive	utils/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange	access:public
blocker	core/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher	access:public
bucket	core/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap	access:public	signature:(int i) const
bucket	mtl/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map	access:public	signature:(int i) const
bucket_count	core/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap	access:public	signature:() const
bucket_count	mtl/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map	access:public	signature:() const
budgetOff	core/Solver.h	/^    void    budgetOff();$/;"	p	class:Minisat::Solver	access:public	signature:()
budgetOff	core/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver	signature:()
buf	mtl/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue	access:private
buf	utils/ParseUtils.h	/^    unsigned char buf[buffer_size];$/;"	m	class:Minisat::StreamBuffer	access:private
buffer_size	utils/ParseUtils.h	/^static const int buffer_size = 1048576;$/;"	m	namespace:Minisat
build	mtl/Heap.h	/^    void build(vec<int>& ns) {$/;"	f	class:Minisat::Heap	access:public	signature:(vec<int>& ns)
bwdsub_assigns	simp/SimpSolver.h	/^    int                 bwdsub_assigns;$/;"	m	class:Minisat::SimpSolver	access:protected
bwdsub_tmpunit	simp/SimpSolver.h	/^    CRef                bwdsub_tmpunit;$/;"	m	class:Minisat::SimpSolver	access:protected
ca	core/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_gt	file:	access:public
ca	core/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	file:	access:public
ca	core/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted	access:public
ca	core/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver	access:protected
ca	simp/SimpSolver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::SimpSolver::ClauseDeleted	access:public
calcAbstraction	core/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause	access:public	signature:()
cancelUntil	core/Solver.cc	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver	signature:(int level)
cancelUntil	core/Solver.h	/^    void     cancelUntil      (int level);                                             \/\/ Backtrack until a certain level.$/;"	p	class:Minisat::Solver	access:protected	signature:(int level)
cap	mtl/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator	access:private
cap	mtl/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map	access:private
cap	mtl/Vec.h	/^    int cap;$/;"	m	class:Minisat::vec	access:private
capacity	mtl/Alloc.h	/^    void capacity(uint32_t min_cap);$/;"	p	class:Minisat::RegionAllocator	access:private	signature:(uint32_t min_cap)
capacity	mtl/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator	signature:(uint32_t min_cap)
capacity	mtl/Vec.h	/^    int      capacity (void) const     { return cap; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
capacity	mtl/Vec.h	/^    void     capacity (int min_cap);$/;"	p	class:Minisat::vec	access:public	signature:(int min_cap)
capacity	mtl/Vec.h	/^void vec<T>::capacity(int min_cap) {$/;"	f	class:Minisat::vec	signature:(int min_cap)
category	utils/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option	access:protected
ccmin_mode	core/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Minisat::Solver	access:public
checkCap	mtl/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map	access:private	signature:(int new_size) const
checkGarbage	core/Solver.h	/^    void    checkGarbage();$/;"	p	class:Minisat::Solver	access:public	signature:()
checkGarbage	core/Solver.h	/^    void    checkGarbage(double gf);$/;"	p	class:Minisat::Solver	access:public	signature:(double gf)
checkGarbage	core/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver	signature:(double gf)
checkGarbage	core/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver	signature:(void)
claBumpActivity	core/Solver.h	/^    void     claBumpActivity  (Clause& c);             \/\/ Increase a clause with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Clause& c)
claBumpActivity	core/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver	signature:(Clause& c)
claDecayActivity	core/Solver.h	/^    void     claDecayActivity ();                      \/\/ Decay all clauses with the specified factor. Implemented by increasing the 'bump' value instead.$/;"	p	class:Minisat::Solver	access:protected	signature:()
claDecayActivity	core/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver	signature:()
cla_inc	core/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver	access:protected
clauseWord32Size	core/SolverTypes.h	/^    static int clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator	access:private	signature:(int size, bool has_extra)
clause_decay	core/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver	access:public
clause_lim	simp/SimpSolver.h	/^    int     clause_lim;        \/\/ Variables are not eliminated if it produces a resolvent with a length above this limit.$/;"	m	class:Minisat::SimpSolver	access:public
clauses	core/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver	access:protected
clauses_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
clean	core/SolverTypes.h	/^    void  clean     (const Idx& idx);$/;"	p	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
clean	core/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)$/;"	f	class:Minisat::OccLists	signature:(const Idx& idx)
cleanAll	core/SolverTypes.h	/^    void  cleanAll  ();$/;"	p	class:Minisat::OccLists	access:public	signature:()
cleanAll	core/SolverTypes.h	/^void OccLists<Idx,Vec,Deleted>::cleanAll()$/;"	f	class:Minisat::OccLists	signature:()
cleanUpClauses	simp/SimpSolver.cc	/^void SimpSolver::cleanUpClauses()$/;"	f	class:SimpSolver	signature:()
cleanUpClauses	simp/SimpSolver.h	/^    void          cleanUpClauses           ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
clear	core/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap	access:public	signature:()
clear	core/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists	access:public	signature:(bool free = true)
clear	mtl/Heap.h	/^    void clear(bool dealloc = false) $/;"	f	class:Minisat::Heap	access:public	signature:(bool dealloc = false)
clear	mtl/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map	access:public	signature:()
clear	mtl/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue	access:public	signature:(bool dealloc = false)
clear	mtl/Vec.h	/^    void     clear    (bool dealloc = false);$/;"	p	class:Minisat::vec	access:public	signature:(bool dealloc = false)
clear	mtl/Vec.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:Minisat::vec	signature:(bool dealloc)
clearInterrupt	core/Solver.h	/^    void    clearInterrupt();     \/\/ Clear interrupt indicator flag.$/;"	p	class:Minisat::Solver	access:public	signature:()
clearInterrupt	core/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver	signature:()
conflict	core/Solver.h	/^    vec<Lit>   conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver	access:public
conflict_budget	core/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	access:protected
conflicts	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
copy	mtl/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat	signature:(const T& from, T& to)
copy	mtl/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat	signature:(const vec<T>& from, vec<T>& to, bool append = false)
copyTo	mtl/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:Minisat::vec	access:public	signature:(vec<T>& copy) const
cost	simp/SimpSolver.h	/^        uint64_t cost  (Var x)        const { return (uint64_t)n_occ[toInt(mkLit(x))] * (uint64_t)n_occ[toInt(~mkLit(x))]; }$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(Var x) const
cpuTime	utils/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat	signature:(void)
cpuTime	utils/System.h	/^static inline double cpuTime(void); \/\/ CPU-time in seconds.$/;"	p	namespace:Minisat	signature:(void)
cref	core/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher	access:public
data	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anon4	access:private
data	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	access:public
data	mtl/Vec.h	/^    T*  data;$/;"	m	class:Minisat::vec	access:private
debug	core/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap	access:public	signature:()
dec_vars	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
decision	core/Solver.h	/^    vec<char>           decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Minisat::Solver	access:protected
decisionLevel	core/Solver.h	/^    int      decisionLevel    ()      const; \/\/ Gives the current decisionlevel.$/;"	p	class:Minisat::Solver	access:protected	signature:() const
decisionLevel	core/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver	signature:() const
decisions	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
decrease	mtl/Heap.h	/^    void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
deleted	core/SolverTypes.h	/^    Deleted   deleted;$/;"	m	class:Minisat::OccLists	access:private
description	utils/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option	access:protected
detachClause	core/Solver.cc	/^void Solver::detachClause(CRef cr, bool strict) {$/;"	f	class:Solver	signature:(CRef cr, bool strict)
detachClause	core/Solver.h	/^    void     detachClause     (CRef cr, bool strict = false); \/\/ Detach a clause to watcher lists.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr, bool strict = false)
dirties	core/SolverTypes.h	/^    vec<Idx>  dirties;$/;"	m	class:Minisat::OccLists	access:private
dirty	core/SolverTypes.h	/^    vec<char> dirty;$/;"	m	class:Minisat::OccLists	access:private
drand	core/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver	access:protected	signature:(double& seed)
eagerMatch	utils/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat	signature:(B& in, const char* str)
elems	mtl/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map	access:public	signature:() const
elim_heap	simp/SimpSolver.h	/^    Heap<ElimLt>        elim_heap;$/;"	m	class:Minisat::SimpSolver	access:protected
elimclauses	simp/SimpSolver.h	/^    vec<uint32_t>       elimclauses;$/;"	m	class:Minisat::SimpSolver	access:protected
eliminate	simp/SimpSolver.cc	/^bool SimpSolver::eliminate(bool turn_off_elim)$/;"	f	class:SimpSolver	signature:(bool turn_off_elim)
eliminate	simp/SimpSolver.h	/^    bool    eliminate   (bool turn_off_elim = false);  \/\/ Perform variable elimination based simplification. $/;"	p	class:Minisat::SimpSolver	access:public	signature:(bool turn_off_elim = false)
eliminateVar	simp/SimpSolver.cc	/^bool SimpSolver::eliminateVar(Var v)$/;"	f	class:SimpSolver	signature:(Var v)
eliminateVar	simp/SimpSolver.h	/^    bool          eliminateVar             (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
eliminated	simp/SimpSolver.h	/^    vec<char>           eliminated;$/;"	m	class:Minisat::SimpSolver	access:protected
eliminated_vars	simp/SimpSolver.h	/^    int     eliminated_vars;$/;"	m	class:Minisat::SimpSolver	access:public
elimorder	simp/SimpSolver.h	/^    int                 elimorder;$/;"	m	class:Minisat::SimpSolver	access:protected
empty	mtl/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap	access:public	signature:() const
end	mtl/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue	access:private
end	utils/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange	access:public
end	utils/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange	access:public
end	utils/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range	access:public
end_inclusive	utils/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange	access:public
enqueue	core/Solver.h	/^    bool     enqueue          (Lit p, CRef from = CRef_Undef);                         \/\/ Test if fact 'p' contradicts current state, enqueue otherwise.$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, CRef from = CRef_Undef)
enqueue	core/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Minisat::Solver	signature:(Lit p, CRef from)
equals	mtl/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map	access:private
extendModel	simp/SimpSolver.cc	/^void SimpSolver::extendModel()$/;"	f	class:SimpSolver	signature:()
extendModel	simp/SimpSolver.h	/^    void          extendModel              ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
extra_clause_field	core/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator	access:public
find	mtl/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat	signature:(V& ts, const T& t)
first	mtl/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue	access:private
free	core/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(CRef cid)
free	mtl/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(int size)
frozen	simp/SimpSolver.h	/^    vec<char>           frozen;$/;"	m	class:Minisat::SimpSolver	access:protected
garbageCollect	core/Solver.cc	/^void Solver::garbageCollect()$/;"	f	class:Solver	signature:()
garbageCollect	core/Solver.h	/^    virtual void garbageCollect();$/;"	p	class:Minisat::Solver	access:public	signature:()
garbageCollect	simp/SimpSolver.cc	/^void SimpSolver::garbageCollect()$/;"	f	class:SimpSolver	signature:()
garbageCollect	simp/SimpSolver.h	/^    virtual void garbageCollect();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
garbage_frac	core/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Minisat::Solver	access:public
gatherTouchedClauses	simp/SimpSolver.cc	/^void SimpSolver::gatherTouchedClauses()$/;"	f	class:SimpSolver	signature:()
gatherTouchedClauses	simp/SimpSolver.h	/^    void          gatherTouchedClauses     ();$/;"	p	class:Minisat::SimpSolver	access:protected	signature:()
getHelpPrefixString	utils/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Minisat::Option	access:protected	signature:()
getLearnts	core/Solver.h	/^    vec<CRef> &	getLearnts			();								\/\/ Retorna las clusulas aprendidas$/;"	p	class:Minisat::Solver	access:public	signature:()
getOptionList	utils/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option	access:protected	signature:()
getUsageString	utils/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option	access:protected	signature:()
grow	simp/SimpSolver.h	/^    int     grow;              \/\/ Allow a variable elimination step to grow by a number of clauses (default to zero).$/;"	m	class:Minisat::SimpSolver	access:public
growTo	core/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, const T& t)
growTo	mtl/Vec.h	/^    void     growTo   (int size);$/;"	p	class:Minisat::vec	access:public	signature:(int size)
growTo	mtl/Vec.h	/^    void     growTo   (int size, const T& pad);$/;"	p	class:Minisat::vec	access:public	signature:(int size, const T& pad)
growTo	mtl/Vec.h	/^void vec<T>::growTo(int size) {$/;"	f	class:Minisat::vec	signature:(int size)
growTo	mtl/Vec.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:Minisat::vec	signature:(int size, const T& pad)
has	core/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, T& t)
has	mtl/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k) const
has_extra	core/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
has_extra	core/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
hash	mtl/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map	access:private
hash	mtl/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(int32_t x)
hash	mtl/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(int64_t x)
hash	mtl/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat	signature:(uint32_t x)
hash	mtl/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat	signature:(uint64_t x)
header	core/SolverTypes.h	/^	}                            header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anon3	access:private
heap	mtl/Heap.h	/^    vec<int> heap;     \/\/ Heap of integers$/;"	m	class:Minisat::Heap	access:private
help	utils/Options.h	/^    virtual void help              (bool verbose = false) = 0;$/;"	p	class:Minisat::Option	access:public	signature:(bool verbose = false)
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption	access:public	signature:(bool verbose = false)
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption	access:public	signature:(bool verbose = false)
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option	access:public	signature:(bool verbose = false)
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption	access:public	signature:(bool verbose = false)
help	utils/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption	access:public	signature:(bool verbose = false)
imax	mtl/Vec.h	/^    static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }$/;"	f	class:Minisat::vec	access:private	signature:(int x, int y)
implied	simp/SimpSolver.cc	/^bool SimpSolver::implied(const vec<Lit>& c)$/;"	f	class:SimpSolver	signature:(const vec<Lit>& c)
implied	simp/SimpSolver.h	/^    bool          implied                  (const vec<Lit>& c);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const vec<Lit>& c)
in	utils/ParseUtils.h	/^    gzFile        in;$/;"	m	class:Minisat::StreamBuffer	access:private
inHeap	mtl/Heap.h	/^    bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }$/;"	f	class:Minisat::Heap	access:public	signature:(int n) const
increase	mtl/Heap.h	/^    void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
index	mtl/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map	access:private	signature:(const K& k) const
indices	mtl/Heap.h	/^    vec<int> indices;  \/\/ Each integers position (index) in the Heap$/;"	m	class:Minisat::Heap	access:private
init	core/SolverTypes.h	/^    void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
insert	core/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr, const T& t)
insert	mtl/Heap.h	/^    void insert(int n)$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
insert	mtl/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Minisat::Map	access:public	signature:(const K& k, const D& d)
insert	mtl/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue	access:public	signature:(T elem)
insertVarOrder	core/Solver.h	/^    void     insertVarOrder   (Var x);                                                 \/\/ Insert a variable in the decision order priority queue.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x)
insertVarOrder	core/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver	signature:(Var x)
interrupt	core/Solver.h	/^    void    interrupt();          \/\/ Trigger a (potentially asynchronous) interruption of the solver.$/;"	p	class:Minisat::Solver	access:public	signature:()
interrupt	core/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver	signature:()
irand	core/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver	access:protected	signature:(double& seed, int size)
isEliminated	simp/SimpSolver.h	/^    bool    isEliminated(Var v) const;$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v) const
isEliminated	simp/SimpSolver.h	/^inline bool SimpSolver::isEliminated (Var v) const { return eliminated[v]; }$/;"	f	class:Minisat::SimpSolver	signature:(Var v) const
isEof	utils/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat	signature:(StreamBuffer& in)
isEof	utils/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat	signature:(const char* in)
key	mtl/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	access:public
l_False	core/SolverTypes.h	84;"	d
l_True	core/SolverTypes.h	83;"	d
l_Undef	core/SolverTypes.h	85;"	d
last	core/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
last	mtl/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
last	mtl/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
lbd	core/SolverTypes.h	/^    uint32_t lbd() { return header.literals_blocks_distance; } ;$/;"	f	class:Minisat::Clause	access:public	signature:()
lbool	core/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool	access:public	signature:(bool x)
lbool	core/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool	access:public	signature:(uint8_t v)
lbool	core/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool	access:public	signature:()
lbool	core/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
lea	core/SolverTypes.h	/^    Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r)
lea	core/SolverTypes.h	/^    const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r) const
lea	mtl/Alloc.h	/^    T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r)
lea	mtl/Alloc.h	/^    const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r) const
learnt	core/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
learnt	core/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
learntMode	core/Solver.h	/^	int			learntMode;$/;"	m	class:Minisat::Solver	access:public
learntParam	core/Solver.h	/^	int			learntParam;$/;"	m	class:Minisat::Solver	access:public
learnts	core/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver	access:protected
learnts_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
learntsize_adjust_cnt	core/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver	access:protected
learntsize_adjust_confl	core/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver	access:protected
learntsize_adjust_inc	core/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver	access:public
learntsize_adjust_start_confl	core/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver	access:public
learntsize_factor	core/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Minisat::Solver	access:public
learntsize_inc	core/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Minisat::Solver	access:public
left	mtl/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
level	core/Solver.h	/^    int      level            (Var x) const;$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
level	core/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
level	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::VarData	access:public
lit	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
litRedundant	core/Solver.cc	/^bool Solver::litRedundant(Lit p, uint32_t abstract_levels)$/;"	f	class:Solver	signature:(Lit p, uint32_t abstract_levels)
litRedundant	core/Solver.h	/^    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       \/\/ (helper method for 'analyze()')$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, uint32_t abstract_levels)
lit_Error	core/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	m	namespace:Minisat
lit_Undef	core/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	m	namespace:Minisat
literals_blocks_distance	core/SolverTypes.h	/^	uint32_t literals_blocks_distance; \/\/ As in GLUCOSE 1.1: a solver that predicts learnt clauses quality $/;"	m	struct:Minisat::Clause::__anon3	access:public
locked	core/Solver.h	/^    bool     locked           (const Clause& c) const; \/\/ Returns TRUE if a clause is a reason for some implication in the current state.$/;"	p	class:Minisat::Solver	access:protected	signature:(const Clause& c) const
locked	core/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Minisat::Solver	signature:(const Clause& c) const
lookup	core/SolverTypes.h	/^    Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
lt	mtl/Heap.h	/^    Comp     lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Minisat::Heap	access:private
luby	core/Solver.cc	/^static double luby(double y, int x){$/;"	f	file:	signature:(double y, int x)
luby_restart	core/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver	access:public
main	core/Main.cc	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
main	simp/Main.cc	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
map	core/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap	access:private
mapVar	core/Solver.cc	/^static Var mapVar(Var x, vec<Var>& map, Var& max)$/;"	f	file:	signature:(Var x, vec<Var>& map, Var& max)
mark	core/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anon3	access:public
mark	core/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
mark	core/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause	access:public	signature:(uint32_t m)
match	utils/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat	signature:(B& in, const char* str)
max_learnts	core/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver	access:protected
max_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
memReadPeak	utils/System.cc	/^static inline int memReadPeak(void)$/;"	f	file:	signature:(void)
memReadStat	utils/System.cc	/^static inline int memReadStat(int field)$/;"	f	file:	signature:(int field)
memUsed	utils/System.cc	/^double Minisat::memUsed() { $/;"	f	class:Minisat	signature:()
memUsed	utils/System.cc	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024); }$/;"	f	class:Minisat	signature:()
memUsed	utils/System.cc	/^double Minisat::memUsed(void) {$/;"	f	class:Minisat	signature:(void)
memUsed	utils/System.h	/^extern double memUsed();            \/\/ Memory in mega bytes (returns 0 for unsupported architectures).$/;"	p	namespace:Minisat	signature:()
memUsedPeak	utils/System.cc	/^double MiniSat::memUsedPeak(void) { return memUsed(); }$/;"	f	class:MiniSat	signature:(void)
memUsedPeak	utils/System.cc	/^double Minisat::memUsedPeak() { $/;"	f	class:Minisat	signature:()
memUsedPeak	utils/System.h	/^extern double memUsedPeak();        \/\/ Peak-memory in mega bytes (returns 0 for unsupported architectures).$/;"	p	namespace:Minisat	signature:()
memory	mtl/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator	access:private
merge	simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)$/;"	f	class:SimpSolver	signature:(const Clause& _ps, const Clause& _qs, Var v, int& size)
merge	simp/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)$/;"	f	class:SimpSolver	signature:(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
merge	simp/SimpSolver.h	/^    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, int& size);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const Clause& _ps, const Clause& _qs, Var v, int& size)
merge	simp/SimpSolver.h	/^    bool          merge                    (const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
merges	simp/SimpSolver.h	/^    int     merges;$/;"	m	class:Minisat::SimpSolver	access:public
mkElimClause	simp/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)$/;"	f	file:	signature:(vec<uint32_t>& elimclauses, Lit x)
mkElimClause	simp/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)$/;"	f	file:	signature:(vec<uint32_t>& elimclauses, Var v, Clause& c)
mkLit	core/SolverTypes.h	/^    friend Lit mkLit(Var var, bool sign = false);$/;"	p	struct:Minisat::Lit	access:friend	signature:(Var var, bool sign = false)
mkLit	core/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f	namespace:Minisat	signature:(Var var, bool sign)
mkVarData	core/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver	access:protected	signature:(CRef cr, int l)
model	core/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Minisat::Solver	access:public
modelValue	core/Solver.h	/^    lbool   modelValue (Lit p) const;       \/\/ The value of a literal in the last model. The last call to solve must have been satisfiable.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p) const
modelValue	core/Solver.h	/^    lbool   modelValue (Var x) const;       \/\/ The value of a variable in the last model. The last call to solve must have been satisfiable.$/;"	p	class:Minisat::Solver	access:public	signature:(Var x) const
modelValue	core/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	signature:(Lit p) const
modelValue	core/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
moveTo	core/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap	access:public	signature:(CMap& other)
moveTo	core/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(ClauseAllocator& to)
moveTo	mtl/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(RegionAllocator& to)
moveTo	mtl/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map	access:public	signature:(Map& other)
moveTo	mtl/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:Minisat::vec	access:public	signature:(vec<T>& dest)
nAssigns	core/Solver.h	/^    int     nAssigns   ()      const;       \/\/ The current number of assigned literals.$/;"	p	class:Minisat::Solver	access:public	signature:() const
nAssigns	core/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver	signature:() const
nClauses	core/Solver.h	/^    int     nClauses   ()      const;       \/\/ The current number of original clauses.$/;"	p	class:Minisat::Solver	access:public	signature:() const
nClauses	core/Solver.h	/^inline int      Solver::nClauses      ()      const   { return clauses.size(); }$/;"	f	class:Minisat::Solver	signature:() const
nFreeVars	core/Solver.h	/^    int     nFreeVars  ()      const;$/;"	p	class:Minisat::Solver	access:public	signature:() const
nFreeVars	core/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Minisat::Solver	signature:() const
nLearnts	core/Solver.h	/^    int     nLearnts   ()      const;       \/\/ The current number of learnt clauses.$/;"	p	class:Minisat::Solver	access:public	signature:() const
nLearnts	core/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return learnts.size(); }$/;"	f	class:Minisat::Solver	signature:() const
nVars	core/Solver.h	/^    int     nVars      ()      const;       \/\/ The current number of variables.$/;"	p	class:Minisat::Solver	access:public	signature:() const
nVars	core/Solver.h	/^inline int      Solver::nVars         ()      const   { return vardata.size(); }$/;"	f	class:Minisat::Solver	signature:() const
n_occ	simp/SimpSolver.h	/^        const vec<int>& n_occ;$/;"	m	struct:Minisat::SimpSolver::ElimLt	access:public
n_occ	simp/SimpSolver.h	/^    vec<int>            n_occ;$/;"	m	class:Minisat::SimpSolver	access:protected
n_touched	simp/SimpSolver.h	/^    int                 n_touched;$/;"	m	class:Minisat::SimpSolver	access:protected
name	utils/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option	access:protected
newDecisionLevel	core/Solver.h	/^    void     newDecisionLevel ();                                                      \/\/ Begins a new decision level.$/;"	p	class:Minisat::Solver	access:protected	signature:()
newDecisionLevel	core/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Minisat::Solver	signature:()
newVar	core/Solver.cc	/^Var Solver::newVar(bool sign, bool dvar)$/;"	f	class:Solver	signature:(bool sign, bool dvar)
newVar	core/Solver.h	/^    Var     newVar    (bool polarity = true, bool dvar = true); \/\/ Add a new variable with parameters specifying variable mode.$/;"	p	class:Minisat::Solver	access:public	signature:(bool polarity = true, bool dvar = true)
newVar	simp/SimpSolver.cc	/^Var SimpSolver::newVar(bool sign, bool dvar) {$/;"	f	class:SimpSolver	signature:(bool sign, bool dvar)
newVar	simp/SimpSolver.h	/^    Var     newVar    (bool polarity = true, bool dvar = true);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(bool polarity = true, bool dvar = true)
nextCap	mtl/Vec.h	/^    static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }$/;"	f	class:Minisat::vec	access:private	signature:(int& cap)
nprimes	mtl/Map.h	/^static const int nprimes          = 25;$/;"	m	namespace:Minisat
occs	core/SolverTypes.h	/^    vec<Vec>  occs;$/;"	m	class:Minisat::OccLists	access:private
occurs	simp/SimpSolver.h	/^                        occurs;$/;"	m	class:Minisat::SimpSolver	access:protected
ok	core/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Minisat::Solver	access:protected
okay	core/Solver.h	/^    bool    okay         () const;                  \/\/ FALSE means solver is in a conflicting state$/;"	p	class:Minisat::Solver	access:public	signature:() const
okay	core/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver	signature:() const
operator !=	core/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(const Watcher& w) const
operator !=	core/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
operator !=	core/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
operator &&	core/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
operator ()	core/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_gt	access:public	signature:(CRef x, CRef y)
operator ()	core/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt	access:public	signature:(CRef x, CRef y)
operator ()	core/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt	access:public	signature:(Var x, Var y) const
operator ()	core/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted	access:public	signature:(const Watcher& w) const
operator ()	core/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash	access:public	signature:(CRef cr) const
operator ()	mtl/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:Minisat::DeepEqual	access:public	signature:(const K* k1, const K* k2) const
operator ()	mtl/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:Minisat::DeepHash	access:public	signature:(const K* k) const
operator ()	mtl/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Minisat::Equal	access:public	signature:(const K& k1, const K& k2) const
operator ()	mtl/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Minisat::Hash	access:public	signature:(const K& k) const
operator ()	mtl/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default	access:public	signature:(T x, T y)
operator ()	simp/SimpSolver.h	/^        bool operator()(Var x, Var y) const { return cost(x) < cost(y); }$/;"	f	struct:Minisat::SimpSolver::ElimLt	access:public	signature:(Var x, Var y) const
operator ()	simp/SimpSolver.h	/^        bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted	access:public	signature:(const CRef& cr) const
operator ()	utils/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt	access:public	signature:(const Option* x, const Option* y)
operator *	utils/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:() const
operator ++	utils/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:()
operator <	core/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
operator =	mtl/Map.h	/^    Map<K,D,H,E>&  operator = (Map<K,D,H,E>& other) { assert(0); }$/;"	f	class:Minisat::Map	access:private	signature:(Map<K,D,H,E>& other)
operator =	mtl/Vec.h	/^    vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }$/;"	f	class:Minisat::vec	access:private	signature:(vec<T>& other)
operator =	utils/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(bool b)
operator =	utils/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(double x)
operator =	utils/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(int64_t x)
operator =	utils/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption	access:public	signature:(int32_t x)
operator =	utils/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption	access:public	signature:(const char* x)
operator ==	core/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	access:public	signature:(const Watcher& w) const
operator ==	core/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
operator ==	core/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit	access:public	signature:(Lit p) const
operator T*	mtl/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
operator []	core/SolverTypes.h	/^    Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r)
operator []	core/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i) const
operator []	core/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i)
operator []	core/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr)
operator []	core/SolverTypes.h	/^    Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
operator []	core/SolverTypes.h	/^    const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(Ref r) const
operator []	core/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr) const
operator []	mtl/Alloc.h	/^    T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r)
operator []	mtl/Alloc.h	/^    const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:(Ref r) const
operator []	mtl/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap	access:public	signature:(int index) const
operator []	mtl/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map	access:public	signature:(const K& k)
operator []	mtl/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map	access:public	signature:(const K& k) const
operator []	mtl/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue	access:public	signature:(int index)
operator []	mtl/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue	access:public	signature:(int index) const
operator []	mtl/Vec.h	/^    T&       operator [] (int index)       { return data[index]; }$/;"	f	class:Minisat::vec	access:public	signature:(int index)
operator []	mtl/Vec.h	/^    const T& operator [] (int index) const { return data[index]; }$/;"	f	class:Minisat::vec	access:public	signature:(int index) const
operator ^	core/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool	access:public	signature:(bool b) const
operator ^	core/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat	signature:(Lit p, bool b)
operator bool	utils/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(void) const
operator bool&	utils/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption	access:public	signature:(void)
operator const Lit*	core/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause	access:public	signature:(void) const
operator const char*	utils/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption	access:public	signature:(void) const
operator const char*&	utils/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption	access:public	signature:(void)
operator double	utils/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(void) const
operator double&	utils/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption	access:public	signature:(void)
operator int32_t	utils/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption	access:public	signature:(void) const
operator int32_t&	utils/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption	access:public	signature:(void)
operator int64_t	utils/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(void) const
operator int64_t&	utils/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option	access:public	signature:(void)
operator ||	core/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool	access:public	signature:(lbool b) const
operator ~	core/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat	signature:(Lit p)
opt_ccmin_mode	core/Solver.cc	/^static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));$/;"	p	file:	signature:(_cat, , , 2, IntRange(0, 2))
opt_clause_decay	core/Solver.cc	/^static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));$/;"	p	file:	signature:(_cat, , , 0.999, DoubleRange(0, false, 1, false))
opt_clause_lim	simp/SimpSolver.cc	/^static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit", 20,   IntRange(-1, INT32_MAX));$/;"	p	file:	signature:(_cat, , , 20, IntRange(-1, INT32_MAX))
opt_garbage_frac	core/Solver.cc	/^static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));$/;"	p	file:	signature:(_cat, , , 0.20, DoubleRange(0, false, HUGE_VAL, false))
opt_grow	simp/SimpSolver.cc	/^static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination step to grow by a number of clauses.", 0);$/;"	p	file:	signature:(_cat, , , 0)
opt_luby_restart	core/Solver.cc	/^static BoolOption    opt_luby_restart      (_cat, "luby",        "Use the Luby restart sequence", true);$/;"	p	file:	signature:(_cat, , , true)
opt_phase_saving	core/Solver.cc	/^static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));$/;"	p	file:	signature:(_cat, , , 2, IntRange(0, 2))
opt_random_seed	core/Solver.cc	/^static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));$/;"	p	file:	signature:(_cat, , , 91648253, DoubleRange(0, false, HUGE_VAL, false))
opt_random_var_freq	core/Solver.cc	/^static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));$/;"	p	file:	signature:(_cat, , , 0, DoubleRange(0, true, 1, true))
opt_restart_first	core/Solver.cc	/^static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));$/;"	p	file:	signature:(_cat, , , 100, IntRange(1, INT32_MAX))
opt_restart_inc	core/Solver.cc	/^static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));$/;"	p	file:	signature:(_cat, , , 2, DoubleRange(1, false, HUGE_VAL, false))
opt_rnd_init_act	core/Solver.cc	/^static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);$/;"	p	file:	signature:(_cat, , , false)
opt_simp_garbage_frac	simp/SimpSolver.cc	/^static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered during simplification.",  0.5, DoubleRange(0, false, HUGE_VAL, false));$/;"	p	file:	signature:(_cat, , , 0.5, DoubleRange(0, false, HUGE_VAL, false))
opt_subsumption_lim	simp/SimpSolver.cc	/^static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption against a clause larger than this. -1 means no limit.", 1000, IntRange(-1, INT32_MAX));$/;"	p	file:	signature:(_cat, , , 1000, IntRange(-1, INT32_MAX))
opt_use_asymm	simp/SimpSolver.cc	/^static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric branching.", false);$/;"	p	file:	signature:(_cat, , , false)
opt_use_elim	simp/SimpSolver.cc	/^static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.", true);$/;"	p	file:	signature:(_cat, , , true)
opt_use_rcheck	simp/SimpSolver.cc	/^static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already implied. (costly)", false);$/;"	p	file:	signature:(_cat, , , false)
opt_var_decay	core/Solver.cc	/^static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.95,     DoubleRange(0, false, 1, false));$/;"	p	file:	signature:(_cat, , , 0.95, DoubleRange(0, false, 1, false))
order_heap	core/Solver.h	/^    Heap<VarOrderLt>    order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Minisat::Solver	access:protected
parent	mtl/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
parse	utils/Options.h	/^    virtual bool parse             (const char* str)      = 0;$/;"	p	class:Minisat::Option	access:public	signature:(const char* str)
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption	access:public	signature:(const char* str)
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption	access:public	signature:(const char* str)
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option	access:public	signature:(const char* str)
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption	access:public	signature:(const char* str)
parse	utils/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption	access:public	signature:(const char* str)
parseFloat	utils/ParseUtils.h	/^static float parseFloat(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
parseInt	utils/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
parseOptions	utils/Options.cc	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat	signature:(int& argc, char** argv, bool strict)
parseOptions	utils/Options.h	/^    friend  void parseOptions      (int& argc, char** argv, bool strict);$/;"	p	class:Minisat::Option	access:friend	signature:(int& argc, char** argv, bool strict)
parseOptions	utils/Options.h	/^extern void parseOptions     (int& argc, char** argv, bool strict = false);$/;"	p	namespace:Minisat	signature:(int& argc, char** argv, bool strict = false)
parse_DIMACS	core/Dimacs.h	/^static void parse_DIMACS(gzFile input_stream, Solver& S) {$/;"	f	namespace:Minisat	signature:(gzFile input_stream, Solver& S)
parse_DIMACS_main	core/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S) {$/;"	f	namespace:Minisat	signature:(B& in, Solver& S)
peek	mtl/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k, D& d) const
peek	mtl/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue	access:public	signature:() const
percolateDown	mtl/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
percolateUp	mtl/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
phase_saving	core/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Minisat::Solver	access:public
pickBranchLit	core/Solver.cc	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver	signature:()
pickBranchLit	core/Solver.h	/^    Lit      pickBranchLit    ();                                                      \/\/ Return the next decision variable.$/;"	p	class:Minisat::Solver	access:protected	signature:()
polarity	core/Solver.h	/^    vec<char>           polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver	access:protected
pop	core/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause	access:public	signature:()
pop	mtl/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue	access:public	signature:()
pop	mtl/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec	access:public	signature:(void)
pos	utils/ParseUtils.h	/^    int           pos;$/;"	m	class:Minisat::StreamBuffer	access:private
position	utils/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer	access:public	signature:() const
primes	mtl/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	m	namespace:Minisat
printStats	core/Main.cc	/^void printStats(Solver& solver)$/;"	f	signature:(Solver& solver)
printStats	simp/Main.cc	/^void printStats(Solver& solver)$/;"	f	signature:(Solver& solver)
printUsageAndExit	utils/Options.cc	/^void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)$/;"	f	class:Minisat	signature:(int argc, char** argv, bool verbose)
printUsageAndExit	utils/Options.h	/^    friend  void printUsageAndExit (int  argc, char** argv, bool verbose);$/;"	p	class:Minisat::Option	access:friend	signature:(int argc, char** argv, bool verbose)
printUsageAndExit	utils/Options.h	/^extern void printUsageAndExit(int  argc, char** argv, bool verbose = false);$/;"	p	namespace:Minisat	signature:(int argc, char** argv, bool verbose = false)
progressEstimate	core/Solver.cc	/^double Solver::progressEstimate() const$/;"	f	class:Solver	signature:() const
progressEstimate	core/Solver.h	/^    double   progressEstimate ()      const; \/\/ DELETE THIS ?? IT'S NOT VERY USEFUL ...$/;"	p	class:Minisat::Solver	access:protected	signature:() const
progress_estimate	core/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver	access:protected
propagate	core/Solver.cc	/^CRef Solver::propagate()$/;"	f	class:Solver	signature:()
propagate	core/Solver.h	/^    CRef     propagate        ();                                                      \/\/ Perform unit propagation. Returns possibly conflicting clause.$/;"	p	class:Minisat::Solver	access:protected	signature:()
propagation_budget	core/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	access:protected
propagations	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
push	mtl/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }$/;"	f	class:Minisat::vec	access:public	signature:(const T& elem)
push	mtl/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:Minisat::vec	access:public	signature:(void)
push_	mtl/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec	access:public	signature:(const T& elem)
qhead	core/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Minisat::Solver	access:protected
random_seed	core/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver	access:public
random_var_freq	core/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver	access:public
range	utils/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption	access:protected
range	utils/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option	access:protected
range	utils/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption	access:protected
readAllLearnt	core/Dimacs.h	/^static void readAllLearnt(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
readClause	core/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f	namespace:Minisat	signature:(B& in, Solver& S, vec<Lit>& lits)
readLearntClauses	core/Dimacs.h	/^static void readLearntClauses(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
readLessActive	core/Dimacs.h	/^static void readLessActive(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
readMoreActive	core/Dimacs.h	/^static void readMoreActive(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
readSmallerThan	core/Dimacs.h	/^static void readSmallerThan(Solver & S, B& learntFile) {$/;"	f	namespace:Minisat	signature:(Solver & S, B& learntFile)
reason	core/Solver.h	/^    CRef     reason           (Var x) const;$/;"	p	class:Minisat::Solver	access:protected	signature:(Var x) const
reason	core/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
reason	core/SolverTypes.h	/^struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::VarData	access:public
rebuildOrderHeap	core/Solver.cc	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver	signature:()
rebuildOrderHeap	core/Solver.h	/^    void     rebuildOrderHeap ();$/;"	p	class:Minisat::Solver	access:protected	signature:()
reduceDB	core/Solver.cc	/^void Solver::reduceDB()$/;"	f	class:Solver	signature:()
reduceDB	core/Solver.h	/^    void     reduceDB         ();                                                      \/\/ Reduce the set of learnt clauses.$/;"	p	class:Minisat::Solver	access:protected	signature:()
reduceDB_gt	core/Solver.cc	/^    reduceDB_gt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_gt	access:public	signature:(ClauseAllocator& ca_)
reduceDB_gt	core/Solver.cc	/^struct reduceDB_gt { $/;"	s	file:
reduceDB_gt::ca	core/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_gt	file:	access:public
reduceDB_gt::operator ()	core/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_gt	access:public	signature:(CRef x, CRef y)
reduceDB_gt::reduceDB_gt	core/Solver.cc	/^    reduceDB_gt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_gt	access:public	signature:(ClauseAllocator& ca_)
reduceDB_lt	core/Solver.cc	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt	access:public	signature:(ClauseAllocator& ca_)
reduceDB_lt	core/Solver.cc	/^struct reduceDB_lt { $/;"	s	file:
reduceDB_lt::ca	core/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	file:	access:public
reduceDB_lt::operator ()	core/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt	access:public	signature:(CRef x, CRef y)
reduceDB_lt::reduceDB_lt	core/Solver.cc	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt	access:public	signature:(ClauseAllocator& ca_)
rehash	mtl/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map	access:private	signature:()
rel	core/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon4	access:public
reloc	core/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator	access:public	signature:(CRef& cr, ClauseAllocator& to)
relocAll	core/Solver.cc	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver	signature:(ClauseAllocator& to)
relocAll	core/Solver.h	/^    void     relocAll         (ClauseAllocator& to);$/;"	p	class:Minisat::Solver	access:protected	signature:(ClauseAllocator& to)
relocAll	simp/SimpSolver.cc	/^void SimpSolver::relocAll(ClauseAllocator& to)$/;"	f	class:SimpSolver	signature:(ClauseAllocator& to)
relocAll	simp/SimpSolver.h	/^    void          relocAll                 (ClauseAllocator& to);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(ClauseAllocator& to)
relocate	core/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause	access:public	signature:(CRef c)
relocation	core/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
reloced	core/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anon3	access:public
reloced	core/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
remove	core/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap	access:public	signature:(CRef cr)
remove	mtl/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat	signature:(V& ts, const T& t)
remove	mtl/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map	access:public	signature:(const K& k)
removeClause	core/Solver.cc	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver	signature:(CRef cr)
removeClause	core/Solver.h	/^    void     removeClause     (CRef cr);               \/\/ Detach and free a clause.$/;"	p	class:Minisat::Solver	access:protected	signature:(CRef cr)
removeClause	simp/SimpSolver.cc	/^void SimpSolver::removeClause(CRef cr)$/;"	f	class:SimpSolver	signature:(CRef cr)
removeClause	simp/SimpSolver.h	/^    void          removeClause             (CRef cr);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(CRef cr)
removeMin	mtl/Heap.h	/^    int  removeMin()$/;"	f	class:Minisat::Heap	access:public	signature:()
removeSatisfied	core/Solver.cc	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver	signature:(vec<CRef>& cs)
removeSatisfied	core/Solver.h	/^    void     removeSatisfied  (vec<CRef>& cs);                                         \/\/ Shrink 'cs' to contain only non-satisfied clauses.$/;"	p	class:Minisat::Solver	access:protected	signature:(vec<CRef>& cs)
remove_satisfied	core/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Minisat::Solver	access:protected
restart_first	core/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Minisat::Solver	access:public
restart_inc	core/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Minisat::Solver	access:public
right	mtl/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap	access:private	signature:(int i)
rnd_decisions	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
rnd_init_act	core/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver	access:public
rnd_pol	core/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver	access:public
satisfied	core/Solver.cc	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver	signature:(const Clause& c) const
satisfied	core/Solver.h	/^    bool     satisfied        (const Clause& c) const; \/\/ Returns TRUE if a clause is satisfied in the current state.$/;"	p	class:Minisat::Solver	access:protected	signature:(const Clause& c) const
saveLearntClauses	core/Solver.cc	/^void Solver::saveLearntClauses() {$/;"	f	class:Solver	signature:()
saveLearntClauses	core/Solver.h	/^    void 		saveLearntClauses	();$/;"	p	class:Minisat::Solver	access:public	signature:()
search	core/Solver.cc	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver	signature:(int nof_conflicts)
search	core/Solver.h	/^    lbool    search           (int nof_conflicts);                                     \/\/ Search for a given number of conflicts.$/;"	p	class:Minisat::Solver	access:protected	signature:(int nof_conflicts)
seen	core/Solver.h	/^    vec<char>           seen;$/;"	m	class:Minisat::Solver	access:protected
selectionSort	mtl/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat	signature:(T* array, int size)
selectionSort	mtl/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	signature:(T* array, int size, LessThan lt)
setConfBudget	core/Solver.h	/^    void    setConfBudget(int64_t x);$/;"	p	class:Minisat::Solver	access:public	signature:(int64_t x)
setConfBudget	core/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver	signature:(int64_t x)
setDecisionVar	core/Solver.h	/^    void    setDecisionVar (Var v, bool b); \/\/ Declare if a variable should be eligible for selection in the decision heuristic.$/;"	p	class:Minisat::Solver	access:public	signature:(Var v, bool b)
setDecisionVar	core/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver	signature:(Var v, bool b)
setFrozen	simp/SimpSolver.h	/^    void    setFrozen (Var v, bool b); \/\/ If a variable is frozen it will not be eliminated.$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v, bool b)
setFrozen	simp/SimpSolver.h	/^inline void SimpSolver::setFrozen    (Var v, bool b) { frozen[v] = (char)b; if (use_simplification && !b) { updateElimHeap(v); } }$/;"	f	class:Minisat::SimpSolver	signature:(Var v, bool b)
setHelpPrefixStr	utils/Options.cc	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat	signature:(const char* str)
setHelpPrefixStr	utils/Options.h	/^    friend  void setHelpPrefixStr  (const char* str);$/;"	p	class:Minisat::Option	access:friend	signature:(const char* str)
setHelpPrefixStr	utils/Options.h	/^extern void setHelpPrefixStr (const char* str);$/;"	p	namespace:Minisat	signature:(const char* str)
setLbd	core/SolverTypes.h	/^    void     setLbd(uint32_t lbd) { header.literals_blocks_distance = lbd; }$/;"	f	class:Minisat::Clause	access:public	signature:(uint32_t lbd)
setPolarity	core/Solver.h	/^    void    setPolarity    (Var v, bool b); \/\/ Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.$/;"	p	class:Minisat::Solver	access:public	signature:(Var v, bool b)
setPolarity	core/Solver.h	/^inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }$/;"	f	class:Minisat::Solver	signature:(Var v, bool b)
setPropBudget	core/Solver.h	/^    void    setPropBudget(int64_t x);$/;"	p	class:Minisat::Solver	access:public	signature:(int64_t x)
setPropBudget	core/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver	signature:(int64_t x)
setUsageHelp	utils/Options.cc	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat	signature:(const char* str)
setUsageHelp	utils/Options.h	/^    friend  void setUsageHelp      (const char* str);$/;"	p	class:Minisat::Option	access:friend	signature:(const char* str)
setUsageHelp	utils/Options.h	/^extern void setUsageHelp     (const char* str);$/;"	p	namespace:Minisat	signature:(const char* str)
shrink	core/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Minisat::Clause	access:public	signature:(int i)
shrink	mtl/Vec.h	/^    void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec	access:public	signature:(int nelems)
shrink_	mtl/Vec.h	/^    void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec	access:public	signature:(int nelems)
sign	core/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat	signature:(Lit p)
simpDB_assigns	core/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Minisat::Solver	access:protected
simpDB_props	core/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Minisat::Solver	access:protected
simp_garbage_frac	simp/SimpSolver.h	/^    double  simp_garbage_frac; \/\/ A different limit for when to issue a GC during simplification (Also see 'garbage_frac').$/;"	m	class:Minisat::SimpSolver	access:public
simplify	core/Solver.cc	/^bool Solver::simplify()$/;"	f	class:Solver	signature:()
simplify	core/Solver.h	/^    bool    simplify     ();                        \/\/ Removes already satisfied clauses.$/;"	p	class:Minisat::Solver	access:public	signature:()
size	core/SolverTypes.h	/^        unsigned size      : 27; $/;"	m	struct:Minisat::Clause::__anon3	access:public
size	core/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause	access:public	signature:() const
size	core/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap	access:public	signature:() const
size	mtl/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:() const
size	mtl/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap	access:public	signature:() const
size	mtl/Map.h	/^    int        size;$/;"	m	class:Minisat::Map	access:private
size	mtl/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue	access:public	signature:() const
size	mtl/Vec.h	/^    int      size     (void) const     { return sz; }$/;"	f	class:Minisat::vec	access:public	signature:(void) const
size	utils/ParseUtils.h	/^    int           size;$/;"	m	class:Minisat::StreamBuffer	access:private
skipLine	utils/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
skipWhitespace	utils/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat	signature:(B& in)
smudge	core/SolverTypes.h	/^    void  smudge    (const Idx& idx){$/;"	f	class:Minisat::OccLists	access:public	signature:(const Idx& idx)
solve	core/Solver.h	/^    bool    solve        ();                        \/\/ Search without assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:()
solve	core/Solver.h	/^    bool    solve        (Lit p);                   \/\/ Search for a model that respects a single assumption.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p)
solve	core/Solver.h	/^    bool    solve        (Lit p, Lit q);            \/\/ Search for a model that respects two assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q)
solve	core/Solver.h	/^    bool    solve        (Lit p, Lit q, Lit r);     \/\/ Search for a model that respects three assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p, Lit q, Lit r)
solve	core/Solver.h	/^    bool    solve        (const vec<Lit>& assumps); \/\/ Search for a model that respects a given set of assumptions.$/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& assumps)
solve	core/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:()
solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p)
solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q)
solve	core/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(Lit p, Lit q, Lit r)
solve	core/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& assumps)
solve	simp/SimpSolver.h	/^    bool    solve       (                     bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:( bool do_simp = true, bool turn_off_simp = false)
solve	simp/SimpSolver.h	/^    bool    solve       (Lit p       ,        bool do_simp = true, bool turn_off_simp = false);       $/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p , bool do_simp = true, bool turn_off_simp = false)
solve	simp/SimpSolver.h	/^    bool    solve       (Lit p, Lit q,        bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, bool do_simp = true, bool turn_off_simp = false)
solve	simp/SimpSolver.h	/^    bool    solve       (Lit p, Lit q, Lit r, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Lit p, Lit q, Lit r, bool do_simp = true, bool turn_off_simp = false)
solve	simp/SimpSolver.h	/^    bool    solve       (const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false)
solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (                     bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:( bool do_simp, bool turn_off_simp)
solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p       ,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p , bool do_simp, bool turn_off_simp)
solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q,        bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, bool do_simp, bool turn_off_simp)
solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)  { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_(do_simp, turn_off_simp) == l_True; }$/;"	f	class:Minisat::SimpSolver	signature:(Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)
solve	simp/SimpSolver.h	/^inline bool SimpSolver::solve        (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& assumps, bool do_simp, bool turn_off_simp)
solveLimited	core/Solver.h	/^    lbool   solveLimited (const vec<Lit>& assumps); \/\/ Search for a model that respects a given set of assumptions (With resource constraints).$/;"	p	class:Minisat::Solver	access:public	signature:(const vec<Lit>& assumps)
solveLimited	core/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Minisat::Solver	signature:(const vec<Lit>& assumps)
solveLimited	simp/SimpSolver.h	/^    lbool   solveLimited(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:public	signature:(const vec<Lit>& assumps, bool do_simp = true, bool turn_off_simp = false)
solveLimited	simp/SimpSolver.h	/^inline lbool SimpSolver::solveLimited (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp){ $/;"	f	class:Minisat::SimpSolver	signature:(const vec<Lit>& assumps, bool do_simp, bool turn_off_simp)
solve_	core/Solver.cc	/^lbool Solver::solve_()$/;"	f	class:Solver	signature:()
solve_	core/Solver.h	/^    lbool    solve_           ();                                                      \/\/ Main solve method (assumptions given in 'assumptions').$/;"	p	class:Minisat::Solver	access:protected	signature:()
solve_	simp/SimpSolver.cc	/^lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)$/;"	f	class:SimpSolver	signature:(bool do_simp, bool turn_off_simp)
solve_	simp/SimpSolver.h	/^    lbool         solve_                   (bool do_simp = true, bool turn_off_simp = false);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(bool do_simp = true, bool turn_off_simp = false)
solver	core/Main.cc	/^static Solver* solver;$/;"	v	file:
solver	simp/Main.cc	/^static Solver* solver;$/;"	v	file:
solves	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
sort	mtl/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat	signature:(vec<T>& v, LessThan lt)
sort	mtl/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat	signature:(T* array, int size)
sort	mtl/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat	signature:(vec<T>& v)
sort	mtl/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	signature:(T* array, int size, LessThan lt)
starts	core/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	access:public
strengthen	core/SolverTypes.h	/^    void         strengthen  (Lit p);$/;"	p	class:Minisat::Clause	access:public	signature:(Lit p)
strengthen	core/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause	signature:(Lit p)
strengthenClause	simp/SimpSolver.cc	/^bool SimpSolver::strengthenClause(CRef cr, Lit l)$/;"	f	class:SimpSolver	signature:(CRef cr, Lit l)
strengthenClause	simp/SimpSolver.h	/^    bool          strengthenClause         (CRef cr, Lit l);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(CRef cr, Lit l)
substitute	simp/SimpSolver.cc	/^bool SimpSolver::substitute(Var v, Lit x)$/;"	f	class:SimpSolver	signature:(Var v, Lit x)
substitute	simp/SimpSolver.h	/^    bool    substitute(Var v, Lit x);  \/\/ Replace all occurences of v with x (may cause a contradiction).$/;"	p	class:Minisat::SimpSolver	access:public	signature:(Var v, Lit x)
subsumes	core/SolverTypes.h	/^    Lit          subsumes    (const Clause& other) const;$/;"	p	class:Minisat::Clause	access:public	signature:(const Clause& other) const
subsumes	core/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause	signature:(const Clause& other) const
subsumption_lim	simp/SimpSolver.h	/^    int     subsumption_lim;   \/\/ Do not check if subsumption against a clause larger than this. -1 means no limit.$/;"	m	class:Minisat::SimpSolver	access:public
subsumption_queue	simp/SimpSolver.h	/^    Queue<CRef>         subsumption_queue;$/;"	m	class:Minisat::SimpSolver	access:protected
sz	mtl/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator	access:private
sz	mtl/Vec.h	/^    int sz;$/;"	m	class:Minisat::vec	access:private
table	mtl/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map	access:private
toDimacs	core/Solver.cc	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver	signature:(FILE* f, Clause& c, vec<Var>& map, Var& max)
toDimacs	core/Solver.cc	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver	signature:(FILE* f, const vec<Lit>& assumps)
toDimacs	core/Solver.cc	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver	signature:(const char *file, const vec<Lit>& assumps)
toDimacs	core/Solver.h	/^    void    toDimacs     (FILE* f, Clause& c, vec<Var>& map, Var& max);$/;"	p	class:Minisat::Solver	access:public	signature:(FILE* f, Clause& c, vec<Var>& map, Var& max)
toDimacs	core/Solver.h	/^    void    toDimacs     (FILE* f, const vec<Lit>& assumps);            \/\/ Write CNF to file in DIMACS-format.$/;"	p	class:Minisat::Solver	access:public	signature:(FILE* f, const vec<Lit>& assumps)
toDimacs	core/Solver.h	/^    void    toDimacs     (const char *file, const vec<Lit>& assumps);$/;"	p	class:Minisat::Solver	access:public	signature:(const char *file, const vec<Lit>& assumps)
toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file)
toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p)
toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p, Lit q);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p, Lit q)
toDimacs	core/Solver.h	/^    void    toDimacs     (const char* file, Lit p, Lit q, Lit r);$/;"	p	class:Minisat::Solver	access:public	signature:(const char* file, Lit p, Lit q, Lit r)
toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file)
toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p)
toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p, Lit q)
toDimacs	core/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Minisat::Solver	signature:(const char* file, Lit p, Lit q, Lit r)
toInt	core/SolverTypes.h	/^    friend int   toInt  (lbool l);$/;"	p	class:Minisat::lbool	access:friend	signature:(lbool l)
toInt	core/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat	signature:(Lit p)
toInt	core/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat	signature:(Var v)
toInt	core/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat	signature:(lbool l)
toLbool	core/SolverTypes.h	/^    friend lbool toLbool(int   v);$/;"	p	class:Minisat::lbool	access:friend	signature:(int v)
toLbool	core/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat	signature:(int v)
toLit	core/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat	signature:(int i)
tot_literals	core/Solver.h	/^    uint64_t dec_vars, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver	access:public
touched	simp/SimpSolver.h	/^    vec<char>           touched;$/;"	m	class:Minisat::SimpSolver	access:protected
trail	core/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Minisat::Solver	access:protected
trail_lim	core/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Minisat::Solver	access:protected
type_name	utils/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option	access:protected
uncheckedEnqueue	core/Solver.cc	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver	signature:(Lit p, CRef from)
uncheckedEnqueue	core/Solver.h	/^    void     uncheckedEnqueue (Lit p, CRef from = CRef_Undef);                         \/\/ Enqueue a literal. Assumes value of literal is undefined.$/;"	p	class:Minisat::Solver	access:protected	signature:(Lit p, CRef from = CRef_Undef)
update	mtl/Heap.h	/^    void update(int n)$/;"	f	class:Minisat::Heap	access:public	signature:(int n)
updateElimHeap	simp/SimpSolver.h	/^    void          updateElimHeap           (Var v);$/;"	p	class:Minisat::SimpSolver	access:protected	signature:(Var v)
updateElimHeap	simp/SimpSolver.h	/^inline void SimpSolver::updateElimHeap(Var v) {$/;"	f	class:Minisat::SimpSolver	signature:(Var v)
use_asymm	simp/SimpSolver.h	/^    bool    use_asymm;         \/\/ Shrink clauses by asymmetric branching.$/;"	m	class:Minisat::SimpSolver	access:public
use_elim	simp/SimpSolver.h	/^    bool    use_elim;          \/\/ Perform variable elimination.$/;"	m	class:Minisat::SimpSolver	access:public
use_rcheck	simp/SimpSolver.h	/^    bool    use_rcheck;        \/\/ Check if a clause is already implied. Prett costly, and subsumes subsumptions :)$/;"	m	class:Minisat::SimpSolver	access:public
use_simplification	simp/SimpSolver.h	/^    bool                use_simplification;$/;"	m	class:Minisat::SimpSolver	access:protected
value	core/Solver.h	/^    lbool   value      (Lit p) const;       \/\/ The current value of a literal.$/;"	p	class:Minisat::Solver	access:public	signature:(Lit p) const
value	core/Solver.h	/^    lbool   value      (Var x) const;       \/\/ The current value of a variable.$/;"	p	class:Minisat::Solver	access:public	signature:(Var x) const
value	core/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	signature:(Lit p) const
value	core/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver	signature:(Var x) const
value	core/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool	access:private
value	utils/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption	access:private
value	utils/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption	access:private
value	utils/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption	access:protected
value	utils/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption	access:protected
value	utils/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option	access:protected
var	core/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat	signature:(Lit p)
varBumpActivity	core/Solver.h	/^    void     varBumpActivity  (Var v);                 \/\/ Increase a variable with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var v)
varBumpActivity	core/Solver.h	/^    void     varBumpActivity  (Var v, double inc);     \/\/ Increase a variable with the current 'bump' value.$/;"	p	class:Minisat::Solver	access:protected	signature:(Var v, double inc)
varBumpActivity	core/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver	signature:(Var v)
varBumpActivity	core/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver	signature:(Var v, double inc)
varDecayActivity	core/Solver.h	/^    void     varDecayActivity ();                      \/\/ Decay all variables with the specified factor. Implemented by increasing the 'bump' value instead.$/;"	p	class:Minisat::Solver	access:protected	signature:()
varDecayActivity	core/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver	signature:()
var_Undef	core/SolverTypes.h	43;"	d
var_decay	core/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver	access:public
var_inc	core/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver	access:protected
vardata	core/Solver.h	/^    vec<VarData>        vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver	access:protected
vec	mtl/Vec.h	/^             vec        (vec<T>& other) { assert(0); }$/;"	f	class:Minisat::vec	access:private	signature:(vec<T>& other)
vec	mtl/Vec.h	/^    explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec	access:public	signature:(int size)
vec	mtl/Vec.h	/^    vec()                       : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:Minisat::vec	access:public	signature:()
vec	mtl/Vec.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec	access:public	signature:(int size, const T& pad)
vec	mtl/Vec.h	/^class vec {$/;"	c	namespace:Minisat
verbosity	core/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver	access:public
wasted	mtl/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator	access:public	signature:() const
wasted_	mtl/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator	access:private
watches	core/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Minisat::Solver	access:protected
withinBudget	core/Solver.h	/^    bool     withinBudget     ()      const;$/;"	p	class:Minisat::Solver	access:protected	signature:() const
withinBudget	core/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver	signature:() const
x	core/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit	access:public
xrealloc	mtl/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat	signature:(void *ptr, size_t size)
~Map	mtl/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map	access:public	signature:()
~Option	utils/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option	access:public	signature:()
~RegionAllocator	mtl/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator	access:public	signature:()
~SimpSolver	simp/SimpSolver.cc	/^SimpSolver::~SimpSolver()$/;"	f	class:SimpSolver	signature:()
~SimpSolver	simp/SimpSolver.h	/^    ~SimpSolver();$/;"	p	class:Minisat::SimpSolver	access:public	signature:()
~Solver	core/Solver.cc	/^Solver::~Solver()$/;"	f	class:Solver	signature:()
~Solver	core/Solver.h	/^    virtual ~Solver();$/;"	p	class:Minisat::Solver	access:public	signature:()
~vec	mtl/Vec.h	/^   ~vec()                                                          { clear(true); }$/;"	f	class:Minisat::vec	access:public	signature:()
