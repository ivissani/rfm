\documentclass[a4paper, 11pt, twoside]{tesis}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{cite}
\usepackage{listings}
\usepackage[colorinlistoftodos, shadow]{todonotes}
% \usepackage[disable]{todonotes}

\begin{document}

%%%% CARATULA
\def\autor{Ignacio Vissani}
\def\titulo{Acelerando ParAlloy mediante la reutilización de cláusulas
aprendidas} 
\def\runtitulo{Acelerando ParAlloy mediante la reutilización de cláusulas
aprendidas}
\def\runtitle{Speeding up ParAlloy reusing learnt clauses}
\def\director{Carlos Gustavo López Pombo}
\def\codirector{Nicolás Leandro Rosner}
\def\lugar{Buenos Aires, 2012}
\input{caratula}

%%%% ABSTRACTS, AGRADECIMIENTOS Y DEDICATORIA
\frontmatter
\pagestyle{empty}
\input{abs_esp.tex}

\cleardoublepage
\input{abs_en.tex}

\cleardoublepage
\input{agradecimientos.tex} % OPCIONAL: comentar si no se quiere

\cleardoublepage
\input{dedicatoria.tex}  % OPCIONAL: comentar si no se quiere

\cleardoublepage
\tableofcontents

\mainmatter
\pagestyle{headings}

\newcommand{\true}{\texttt{TRUE}\xspace}
\newcommand{\false}{\texttt{FALSE}\xspace}
\newcommand{\sat}{\emph{sat}\xspace}
\newcommand{\unsat}{\emph{unsat}\xspace}
\newcommand{\cnf}{\texttt{\textbf{CNF}}\xspace}
\newcommand{\npc}{\textbf{NP-Complete}\xspace}
\newcommand{\bt}{\emph{backtracking}\xspace}

\newcommand{\soft}{\emph{software}\xspace}
\newcommand{\hard}{\emph{hardware}\xspace}

\listoftodos

\chapter{Introducción}

\input{intro.tex}


\chapter{Preliminares}

\newcommand{\disj}[1]{\ensuremath{[#1]}}
\newcommand{\conj}[1]{\ensuremath{\{#1\}}}

\section{El problema de la SATisfactiblidad}

El problema de la satisfactibilidad (\emph{SAT problem}) consiste en determinar
si existe alguna asignación de valores de verdad (\true|\false) a cada una de
las variables booleanas que aparecen en una fórmula $\phi$ de la lógica
proposicional de modo que $\phi$ se haga verdadera. En caso de que dicha
asignación exista decimos que $\phi$ es satisfacible (o simplemente \sat) y la
asignación o valuación $\{ v_1 \leftarrow V_1, \ldots, v_n \leftarrow V_n \}$
correspondiente es un \textbf{modelo} de $\phi$. Es importante notar que en caso
de que una fórmula sea \sat podría existir más de una valuación que haga que la
fórmula sea verdadera. Si no existe ninguna valuación que haga verdadera a
$\phi$ decimos que $\phi$ es insatisfacible (o \unsat).

El problema de determinar si una fórmula $\phi$ dada es \sat o \unsat pertenece
a la clase de problemas \npc\cite{Cook:1971:CTP:800157.805047}. Es decir que no
se conoce un algoritmo cuya complejidad temporal sea polinomial que pueda determinar si una fórmula es \sat
o \unsat. La importancia que reviste el problema SAT para diversas áreas de las
ciencias de la computación, como ser el diseño de circuitos o la verificación
automática, ha impulsado el desarrollo de algoritmos relativamente eficientes
para una clase amplia de problemas conocidos como \emph{SAT solvers}.

\subsection{\emph{SAT Solving}}

Se conoce con el nombre de \emph{SAT solvers} a los algoritmos que permiten
determinar si una fórumla $\phi$ de la lógica proposicional tiene alguna
valuación que la haga verdadera. El algoritmo general de  \emph{SAT solving}
consiste en un algoritmo de \bt que podríamos esquematizar como sigue:

\missingfigure{Algoritmo DPLL}
% \begin{lstlisting}[mathescape,language=python]
% algoritmo?
% \end{lstlisting}

La mayoría de los \emph{SAT solvers} son
variaciones del algoritmo general
DPLL\cite{Davis:1962:MPT:368273.368557} y actúan sobre fórmulas
proposicionales expresadas en Forma Normal Conjuntiva (\cnf).

\subsection{Forma Normal Conjuntiva}

Decimos que una fórmula de la lógica proposicional se encuentra en Forma Normal
Conjuntiva (\cnf por sus siglas en inglés) si la misma es una conjunción de
disyunciones de literales; donde un literal es una variable $v$ o su negación
$-v$.

Por ejemplo, la fórmula $\phi = (p \vee q) \wedge (-p \vee q)$ se encuentra
en \cnf. Dado que los conectores lógicos están implícitos cuando una fórmula se
encuentra en \cnf normalmente escribimos $\phi = \conj{\disj{p, q}, \disj{-p,
q}}$ de modo equivalente.

\subsection{Algoritmo DPLL}

El algoritmo DPLL es un procedimiento 

\subsection{Aprendizaje}
\subsubsection{First UIP}
\subsubsection{Recorte de la base de datos}
\subsubsection{Actividad y LBD}

\section{Alloy}

\section{ParAlloy}
\subsection{BEDs}

\section{\emph{SAT Solving} distribuido}

\subsection{Aprendizaje}

\chapter{Técnica}



\chapter{Experimental}

\chapter{Conclusiones y trabajo futuro}

\section{Trabajo futuro}
- Portfolio

\bibliography{tesisbib}{}
\bibliographystyle{plain}

\end{document}
