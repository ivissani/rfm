\documentclass[a4paper, 11pt]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{framed}
\usepackage{paralist}
\usepackage[usenames]{color}
\usepackage{colortbl}
\usepackage{url}

\fontfamily{Arial}

\usepackage[vcentering]{geometry}
\geometry{top=2cm, bottom=2cm, right=2cm, left=2cm}

\newcommand{\boxedcomment}[1]{%
\begin{framed}
 #1
\end{framed}
}

\begin{document}

\begin{Large}
 \begin{center}
    Un \emph{framework} formal para el desarrollo de especificaciones heterogéneas en software orientado a servicios
 \end{center}

\end{Large}


\section{Objetivos}
  El mundo del desarrollo de software se ha vuelto intrínsecamente heterogéneo. Por un lado, los analistas y diseñadores tienen a su disposición una miríada de lenguajes y notaciones para capturar y modelar distintos aspectos del software. Por ejemplo, UML \cite{omg-sysml04,omg-ocl04} ofrece un conjunto de notaciones en forma de diagramas que van desde diagramas de clases hasta diagramas de estado, diagramas de colaboración, etc. Esta proliferación refleja la necesidad de reducir la complejidad del desarrollo de grandes sistemas ya que cada lenguaje permite a los ingenierios concentrarse en una vista o etapa específica del proceso de desarrollo. Lo mismo ocurre en el nivel de los formalismos que proveen soporte formal al uso de dichos lenguajes y métodos: se ha utilizado lógica ecuacional para tipos de datos, lógica temporal para comportamiento reactivo, funciones de alto orden para seguridad, etc. Como consecuencia de esto existen muchas notaciones y lenguajes de entrada distintos para las herramientas. A su vez, los usuarios también tienen sus hábitos y preferencias por lenguajes particulares. En resumen, el escenario que enfrentamos hoy en día es el de una multitud de lenguajes de modelado y lógicas de soporte, y de herramientas para el procesamiento de dichos lenguajes mediante el razonamiento en las lógicas subyacentes.
  
  Estos entornos de diseño y desarrollo introducen a la heterogeneidad como la principal fuente de complejidad ya que la misma torna sumamente difícil, casi imposible, comprender cómo los sistemas se comportarán e interactuarán con las personas y con otros sistemas. Esta es la razón por la cual, en los últimos años, el campo de los fundamentos de las ciencias de la computación ha presenciado un crecimiento del interés en el problema de lograr proveer fundamentos formales para el diseño de software heterogéneo.
  
  Por otro lado, en el actual contexto de computación global ubicua, la estructura de los sistemas de software se está volviendo más y más dinámica ya que las aplicaciones necesitan poder responder y adaptarse a los cambios en el entorno en el que operan. Por ejemplo el nuevo paradigma de software orientado a servicios (SOC) soporta una nueva generación de aplicaciones de software que se ejecutan  sobre infraestructuras de red y computacionales disponibles globalmente desde las cuales pueden obtener servicios dinámicamente (sujeto a una negociación de un \emph{Service Level Agreement} - SLA) y unirse a los mismos de modo que, colectivamente, puedan alcanzar los objetivos de negocio dados. No existe ninún control sobre la naturaleza de los componentes a los que una aplicación puede unirse. En particular, el desarrollo ya no se lleva a cabo de una manera \emph{top-down} en la que los subsistemas son desarrollados e integrados por ingenieros preparados: en SOC, el descubrimiento y la unión son realizadas por el \emph{middleware}. Por lo tanto, no es necesariamente cierto que este nivel extra de heterogeneidad, derivado de cosas que ocurren en tiempo de ejecución, pueda ser manejado a través de traducciones (en tiempo de diseño) a un lenguaje común. 
  
  Desde un punto de vista general, los objetivos del proyecto se centran en hacer contribuciones en dos campos a partir de:
  \begin{itemize}
   \item proveer fundamentos formales para el diseño y desarrollo de software orientado a servicios soportando esta nueva concepción de heterogeneidad derivada del mismo, y
   \item el desarrollo de herramientas para el diseño, valiación y verificación de este tipo de software
  \end{itemize}

  El proyecto propone entonces el desarrollo de los dos aspectos principales señalados anteriormente en una forma interrelacionada. En cuanto al problema de lidiar con las descripciones heterogéneas de las piezas de software proponemos el desarrollo de un \emph{framework} teórico más flexible que el basado en la representación con instituciones. El objetivo de esto es subsanar las limitaciones provenientes del hecho de que dicha representación está enfocada en resolver la integración en tiempo de diseño: una institución es la formalización de una lógica, una representación mediante instituciones provee los medios para traducir una lógica en otra de modo que se preserve la semántica. Normalmente, la heterogeneidad es tratada mediante la traducción de diferentes lenguajes a un único lenguaje más expresivo en la que las diferentes vistas son homogeneizadas, es decir, integradas en una única descripción. El nuevo \emph{framework} se basará en la noción de interoperabilidad de los lenguajes y atacará tres importantes limitaciones de los enfoques actualmente disponibles:
  \begin{inparaenum}[\itshape a\upshape)]
  \item el hecho de que, debido a que las instituciones fueron definidas para dar cuenta de las lógicas, las mismas no son, necesariamente, la abstracción adecuada para manejar los lenguajes y notaciones utilizados para el modelado o especificación de sistemas;
  \item la falta de una noción apropiada de especificaciín para sistemas heterogéneos que soporte \emph{dynamic (service-oriented) binding}; y
  \item la carencia de herramientas que soporten adecuadamente los métodos formales basados en este nuevo concepto
  \end{inparaenum}
  
  El desarrollo de un \emph{framework} con estas características requerirá de una serie de tareas. El primer objetivo es el estudio del estado del arte en el campo de las especificaciones heterogéneas de modo de identificar sus limitaciones para lidiar con lenguages no lógicos como UML o SCA. La literatura existente sobre especificaciones heterogéneas se concentra en lenguajes lógicos formalizados como instituciones \cite{goguen:cmwlp84} y en traducciones con preservación de la semántica entre ellos, formalizados como morfismos entre instituciones \cite{goguen:jacm-39_1} y representaciones entre instituciones \cite{tarlecki:sadt-rtdts95}. Las instituciones de Grothendieck \cite{diaconescu:acs-10_4} son un paso adelante en el campo de las especificaciones heterogéneas porque internalizan las traducciones como morfismos heterogéneos entre teorías introduciendo el concepto de lenguaje heterogéneo cuyo modelo será interpretado de acuerdo con las proyecciones inducidas por estos morfismos en la correspondiente clase de modelos.
  
  REVISAR -
  En muchos casos uno puede idear codificaciones de dichos lenguajes en instituciones al costo de perder el significado de una gramática o teoría de modelos. Por ejemplo, las instituciones fuerzan que los mapeos sean transformaciones naturales sobre functores gramáticos, lo que es demasiado restrictivo en situaciones donde es posible encontrar traducciones (usualmente parciales) entre REVISAR - oraciones - REVISAR (no estructuradas). En el nivel de las teorías de modelos, la condición de satisfactibilidad (una propiedad estructural que requiere que la satisfactibilidad de los predicados sea independiente de las firmas) impide la definición de mapeos que operan sobre subdominios que son dependientes de las firmas.
  - REVISAR
  
  Es por esto que proponemos trabajar hacia una noción de formalismos de especificación más flexible (como la de categorías coordenadas de Fiadeiro o las lógicas de especificación de Ehrig) y desarrollar una noción de interoperabilidad  que (BLA BLA BLA) sino a una noción de conector similar a la usada en arquitectura de software. Un conector (un concepto conocido en arquitectura del software) debe soportar un cierto nivel de interoperabilidad a partir de declarar en sus roles los elementos que son necesarios abstraer de los lenguajes que serán  conectados (que pueden ser tanto sintácticos como semánticos, o una mezcla de ambos) y el mecanismo a través del cual se lleva a cavo la integración.

  Uno de los objetivos del proyecto es desarrollar bases teóricas similares a aquellas existentes para los lenguajes lógicos pero para lenguajes no lógicos basándose en el concepto de interoperabilidad en lugar de en el de representación de lenguajes.
  
  También pretendemos incluir otras características que han sido extensamente estudiadas para los lenguajes lógicos, como mecanismos de estructuración de especificaciones \cite{borzyszkowski:tcs-286_2,lopezpombo:ictac10}. Los mecanismos de estructuración proveen formas de copmrender a las teorías como resultado de un proceso dinámico de diseño de software. Creemos que esta es la forma correcta de comprender cómo se construyen los sistemas, de un modo incremental y evolutivo. Por lo tanto esto los convierte en una necesidad  a la hora de impulsar esta concepción novedosa sobre el diseño de software heterogéneo, especialmente si queremos que esta metodología sea adoptada en la práctica del diseño y desarrollo de software.
  
  Sobre los mecanismos de estructuración, se debe tener en cuenta que los mismos deben operar también en canales. En particular, proponemos revisar la noción de conector de alto orden desarrollada en \cite{lopez+:acmtosem-12_1} para arquitecturas de software que está inspirada en la noción de módulo de alto orden de las especificaciones algebraicas.
  
  El proyecto entonces estará centrado en el desarrollo de los fundamentos teóricos para la construcción y composición de especificaciones heterogéneas basándose en el concepto de interoperabilidad (en lugar de en la representación de lenguajes) que puede ser usado tanto en tiempo de disenño como de ejecución, y en la validación de esos fundamentos sobre aquellas notaciones de la ingeniría del software, métodos y lenguajes en los que la heterogeneidad es un aspecto clave. Para lograr esto proponemos:

  \begin{itemize}
  \item establecer las limitaciones del enfoque tradicional basado en instituciones tanto para actuar como \emph{framework} formal para lenguages no lógicos como para lidiar con conceptos como la interoperabilidad o el \emph{dynamic binding}, ambos esenciales en las arquitecturas orientadas a servicios,
  
  \item definir los fundamentos formales para un \emph{framework} heterogéneo basado en el concepto de interoperabilidad. Esto es particularmente desafiante y novedoso en tanto que, contrariamente a lo posibilitado por el enfoque basado en instituciones, la integración en tiempo de ejecución no puede ser resuelta de forma estática durante la etapa de diseño,
  
  \item desarrollar el prototipo de una herramienta que soporte el diseño de software heterogéneo orientado a servicios.
  \end{itemize}

\section{Antecedentes}

\newcommand{\paperola}{\emph{An Abstract Heterogeneous Characterization of Component Based Systems in a Categorical Setting}}

\section{Actividades y metodología}
El primer paso del trabajo será la evaluación del estado del arte en búsqueda de los límites de los enfoques tradicionales sobre heterogeneidad aplicados al software concebido como servicios. La pieza clave en esto es la noción de interoperabilidad de las piezas de software en lugar de la tradicional comunicación en un lenguaje común. La noción de interoperabilidad está más relacionada con el concepto de puerto proveniente del campo de la arquitectura de software. Allí un canal de comunicación tiene su propio comportamiento, similar al rol de un protocolo de comunicación que reglamenta la negociación de los términos bajo los cuales los componentes se unirán con el fin de proveer un servicio. Una forma de interpretar esta noción dentro de los conceptos provenientes de las instituciones es el que el grupo presenta en el artículo \paperola\ actualmente enviado para su evaluación a la revista \emph{Theoretical Computer Science}.

Basándonos en la noción de interoperabilidad desarrollada, la propuesta es desarrollar una noción de especificación heterogénea que generalice la actualmente disponible para instituciones de Grothendieck \cite{diaconescu:acs-10_4} como es usada por Diaconescu y Futatsugi \cite{diaconescu:tcs-285_2} y por Mossakowski \cite{mossakowski:tacas07} (una ``colección'' de teorías en instituciones diferentes) al caso en el que no necesariamente estamos trabajando con teorías de lógicas (instituciones) sino con elementos de una configuración de formalismos de especificación. En este caso una especificación heterogénea debe ser considerada como un grafo etiquetado con los objetos de esos formalismos interconectado por instancias de los conectores que, en la configuración de los formalismos, garantice la interoperabilidad entre los formalismos involucrados.

También se debe generalizar, en el caso en el que los lenguajes son instituciones, el concepto de \emph{canal} \cite{fiadeiro:amast96} e incluso la noción compleja de \emph{conección} que el grupo presentó en el artículo \paperola. En este nuevo \emph{framework}, la noción de canal basada en conectores debería solucionar los problemas que surgen al trabajar con instituciones de Grothendieck debido al hecho de que las relaciones son establecidas directamente entre las descripciones lógicas por medio de morfismos, lo que necesariamente incluye el uso de un morfismo o representación entre instituciones entre las diferentes instituciones. Lo mismo ocurre con otros enfoques como el de institución ``universal'' de Tarlecki.

Uno de los desafíos que tendremos que enfrentar es la habilidad para inferir propiedades sobe las especificaciones heterogéneas basándonos en la naturaleza de los canales. Por ejemplo una de las estructuras que necesita ser tenida en cuenta surge de la necesidad de lidiar con las situaciones en las que distintos aspectos de una misma entidad deben ser especificados, como en UML. Dependiendo de la naturaleza de los canales deberemos ser capaces de formular y analizar propiedades de compatibilidad y consistencia.

\noindent En concreto el plan de trabajo será:

\begin{itemize}
 \item Año 1:
 \begin{itemize}
  \item Estudio de la semántica formal de UML y SCA
  \item Estudio de los \emph{frameworks} existentes para especificaciones heterogéneas
  \item Definición de las características del \emph{framework} a desarrollar
 \end{itemize}

 \item Año 2:
 \begin{itemize}
  \item Definición de los fundamentos teóricos del \emph{framework}
  \item Desarrollo de los casos de estudio
  \item Definición de la arquitectura de una herramienta para el \emph{framework}
 \end{itemize}
 
 \item Año 3:
 \begin{itemize}
  \item Implementación de un prototipo de herramienta para el \emph{framework}
  \item Testeo usando los casos de estudio
  \item Evaluación del \emph{framework}
  \item Reporte de los resultados
 \end{itemize}


\end{itemize}


\section{Factibilidad}

El desarrollo del trabajo se llevará a cabo en el Departamento de Computación de la Facultad de Ciencias Exactas y Naturales de la Universidad de Buenos Aires. En el mismo se cuenta con espacio de trabajo dentro de la oficina del grupo de Métodos Formales Relacionales. Allí se cuenta con materiales de trabajo adecuados (espacio físico, equipamiento informático, bibliografía, etc.).

Además, el investigador principal del mismo y futuro director de beca realiza una colaboración desde hace dos años, con varias contribuciones tanto en conferencias como en revistas, con investigadores de dos universidades. Con el Prof. Tomas S. E. Maibaum de McMaster University, Hamilton, Ontario, Canada y con el Prof. Nazareno Aguirre y Pablo Castro de la Universidad Nacional de Río Cuarto, Río Cuarto, Córdoba, Argentina. Además se está iniciando una colaboración a través del proyecto internacional \emph{MEALS: Mobility between Europe and Argentina apllying Logics to Systems} financiada por \emph{Marie Curie Actions} bajo el programa \emph{International Research Staff Exchange Scheme} con el Prof. José Luiz Fiadeiro (una referencia renombrada en este campo) en la Leicester University, Leicester, United Kingdom.

Como resultado de estas colaboraciones el grupo ya ha publicado sus primeros resultados en \cite{castro:ictac10}. En este trabajo se desarrolló un \emph{framework} formal para dar semántica a un lenguaje para describir arquitecturas de software. Además se escribió una versión para la revista \emph{Theoretical Computer Science} bajo el título \paperola\ que se encuentra actualmente en evaluación. En este momento se está trabajando en la confección de dos nuevos artículos. Por un lado una versión extendida del artículo antes mencionado cuyas definiciones preliminares y resultados fueron presentadas en la reunión IFIP WG 1.3 llevada a cabo en Salamanca durante Junio de 2012, donde el futuro director de beca fue invitado como observador. Por otro lado un artículo también emergente del trabajo presentado en \cite{castro:ictac10} sobre la utilización de este \emph{framework} para formalizar el concepto de promoción de esquemas utilizado en Z \cite{spivey88}, B \cite{abrial96}, y otros lenguajes.

Además el grupo posee amplia experiencia en el campo de desarrollo de herramientas para dar soporte a métodos formales. La primera contribución del grupo en este aspecto \cite{lopezpombo:SRI-CSL-02-04} fue la incorporación semántica de una extensión de las \emph{fork algebras} dentro de la lógica de alto orden de modo de usar PVS \cite{owre:cade92} como un demostrador de teoremas interactivo basándose en el cálculo de secuentes. En \cite{frias:icfem04} el grupo presentó un cálculo completo basado en la traducción del lenguaje {\sf Alloy} a una clase de \emph{fork algebras}, y de este trabajo y de \cite{lopezpombo:SRI-CSL-02-04}, en \cite{frias:tacas07}, el grupo construyó un demostrador de teoremas para {\sf Alloy} llamado Dynamite (\url{http://www.dc.uba.ar/dps}). El grupo también en la construcción de un \emph{sat-solver} paralelo y distribuido para ser utilizado en la validación de especificaciones {\sf Alloy}. Esta herramienta se presentó en \cite{rosner:abz10}. Esta herramienta fue utilizada eficientemente en la validación de programas orientados a objetos que el grupo reportó en \cite{galeotti:apv09,galeotti:issta10}.

\section{Bibliografía}

\begin{small}
\bibliographystyle{alpha}
\bibliography{bibdatabase}
\end{small}

\end{document}