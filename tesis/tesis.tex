\documentclass[a4paper, 11pt, twoside]{tesis}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{cite}
\usepackage{listings}
\usepackage[colorinlistoftodos, shadow]{todonotes}
% \usepackage[disable]{todonotes}

\begin{document}

%%%% CARATULA
\def\autor{Ignacio Vissani}
\def\titulo{Acelerando ParAlloy mediante la reutilización de cláusulas
aprendidas} 
\def\runtitulo{Acelerando ParAlloy mediante la reutilización de cláusulas
aprendidas}
\def\runtitle{Speeding up ParAlloy reusing learnt clauses}
\def\director{Carlos Gustavo López Pombo}
\def\codirector{Nicolás Leandro Rosner}
\def\lugar{Buenos Aires, 2012}
\input{caratula}

%%%% ABSTRACTS, AGRADECIMIENTOS Y DEDICATORIA
\frontmatter
\pagestyle{empty}
\input{abs_esp.tex}

\cleardoublepage
\input{abs_en.tex}

\cleardoublepage
\input{agradecimientos.tex} % OPCIONAL: comentar si no se quiere

\cleardoublepage
\input{dedicatoria.tex}  % OPCIONAL: comentar si no se quiere

\cleardoublepage
\tableofcontents

\mainmatter
\pagestyle{headings}

\newcommand{\true}{\texttt{TRUE}\xspace}
\newcommand{\false}{\texttt{FALSE}\xspace}
\newcommand{\sat}{\emph{sat}\xspace}
\newcommand{\unsat}{\emph{unsat}\xspace}
\newcommand{\cnf}{\texttt{\textbf{CNF}}\xspace}
\newcommand{\npc}{\textbf{NP-Complete}\xspace}
\newcommand{\bt}{\emph{backtracking}\xspace}

\newcommand{\soft}{\emph{software}\xspace}
\newcommand{\hard}{\emph{hardware}\xspace}

\listoftodos

\chapter{Introducción}

En la actualidad el \soft forma parte integral de nuestra vida cotidiana. El
mismo interviene en todo tipo de teras. Desde el envío de un mensaje de texto o
la realización de una llamada telefónica hasta el sistema de control de una
central nuclear, pasando por el control de un ascensor o el sistema de velocidad
crucero de un automóvil, utilizan sistemas basados en \hard y \soft
informático. La variedad, alcance y \textbf{criticidad} de las responsabilidades
asignadas a las piezas de \soft hacen de las mismas un componente de alto
impacto en nuestra realidad actual. 

Por otra parte, la alta complejidad del \soft hace que la construcción del mismo
sea una tarea propensa a errores. El impacto de una falla en un componente de
\soft puede variar desde la imposibilidad de utilizar un artefacto doméstico
hasta una catástofre de magnitudes como la fundición del núcleo de un reactor
nuclear. 

Son estos aspectos los que motivan la necesidad creciente de construir métodos
(formalismos, metodologías, herramientas, etc.) que permitan garantizar la
calidad del \soft en un sentido general. La posibilidad de establecer la
ausencia de errores en un programa radica en la capacidad de establecer
inequívocamente que ese programa cumple una determinada propiedad. Por ejemplo
¿Será cierto que no es posible encender el microondas si la puerta está abierta?


\chapter{Preliminares}

\newcommand{\disj}[1]{\ensuremath{[#1]}}
\newcommand{\conj}[1]{\ensuremath{\{#1\}}}

\section{El problema de la SATisfactiblidad}

El problema de la satisfactibilidad (\emph{SAT problem}) consiste en determinar
si existe alguna asignación de valores de verdad (\true|\false) a cada una de
las variables booleanas que aparecen en una fórmula $\phi$ de la lógica
proposicional de modo que $\phi$ se haga verdadera. En caso de que dicha
asignación exista decimos que $\phi$ es satisfacible (o simplemente \sat) y la
asignación o valuación $\{ v_1 \leftarrow V_1, \ldots, v_n \leftarrow V_n \}$
correspondiente es un \textbf{modelo} de $\phi$. Es importante notar que en caso
de que una fórmula sea \sat podría existir más de una valuación que haga que la
fórmula sea verdadera. Si no existe ninguna valuación que haga verdadera a
$\phi$ decimos que $\phi$ es insatisfacible (o \unsat).

El problema de determinar si una fórmula $\phi$ dada es \sat o \unsat pertenece
a la clase de problemas \npc\cite{Cook:1971:CTP:800157.805047}. Es decir que no
se conoce un algoritmo cuya complejidad temporal sea polinomial que pueda determinar si una fórmula es \sat
o \unsat. La importancia que reviste el problema SAT para diversas áreas de las
ciencias de la computación, como ser el diseño de circuitos o la verificación
automática, ha impulsado el desarrollo de algoritmos relativamente eficientes
para una clase amplia de problemas conocidos como \emph{SAT solvers}.

\subsection{\emph{SAT Solving}}

Se conoce con el nombre de \emph{SAT solvers} a los algoritmos que permiten
determinar si una fórumla $\phi$ de la lógica proposicional tiene alguna
valuación que la haga verdadera. El algoritmo general de  \emph{SAT solving}
consiste en un algoritmo de \bt que podríamos esquematizar como sigue:

\missingfigure{Algoritmo DPLL}
% \begin{lstlisting}[mathescape,language=python]
% algoritmo?
% \end{lstlisting}

La mayoría de los \emph{SAT solvers} son
variaciones del algoritmo general
DPLL\cite{Davis:1962:MPT:368273.368557} y actúan sobre fórmulas
proposicionales expresadas en Forma Normal Conjuntiva (\cnf).

\subsection{Forma Normal Conjuntiva}

Decimos que una fórmula de la lógica proposicional se encuentra en Forma Normal
Conjuntiva (\cnf por sus siglas en inglés) si la misma es una conjunción de
disyunciones de literales; donde un literal es una variable $v$ o su negación
$-v$.

Por ejemplo, la fórmula $\phi = (p \vee q) \wedge (-p \vee q)$ se encuentra
en \cnf. Dado que los conectores lógicos están implícitos cuando una fórmula se
encuentra en \cnf normalmente escribimos $\phi = \conj{\disj{p, q}, \disj{-p,
q}}$ de modo equivalente.

\subsection{Algoritmo DPLL}

El algoritmo DPLL es un procedimiento 

\subsection{Aprendizaje}
\subsubsection{First UIP}
\subsubsection{Recorte de la base de datos}
\subsubsection{Actividad y LBD}

\section{Alloy}

\section{ParAlloy}
\subsection{BEDs}

\section{\emph{SAT Solving} distribuido}

\subsection{Aprendizaje}

\chapter{Técnica}



\chapter{Experimental}

\chapter{Conclusiones y trabajo futuro}

\section{Trabajo futuro}
- Portfolio

\bibliography{tesisbib}{}
\bibliographystyle{plain}

\end{document}
