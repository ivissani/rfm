%!TEX root = tesis.tex


\chapter{Un \ssolver paralelo y distribuido }
\label{ssolver-pardist}

El objetivo principal de todo sistema distribuido es que el mismo sea
\textbf{escalable}. Si bien la escalabilidad puede ser entendidad en
diferentes sentidos, nos interesa en particular que el sistema haga posible la
utilización de mayor cantida de \hard para resolver el problema (en nuestro
caso un problema \sat) y que esa utilización de mayor poder de cómputo reporte
ganancias en términos de tiempo (percibido) invertido en resolver un
determinado problema o bien en términos de empujar la frontera de lo
resoluble.

La escalabilidad como gran objetivo rector en el desarrollo de nuestra
herramienta introduce una serie de desafíos a saber:

La necesidad de que los nodos de trabajo (\ws) sean símetricos en
tanto que esto permite mayor dinamismo, y por lo tanto mejor utilización del
\hard disponible. La simetría entendida en su máxima expresión como la
posibilidad de que todas las unidades de procesamiento puedan realizar todas
las funciones necesarias provee la capacidad de distribuir la carga de trabajo
de la manera más conveniente en cada momento. Esto no podría ser logrado si
los nodos de trabajo tuvieran funciones específicas ya que se podría dar el
caso de tener nodos ociosos porque no hay trabajo pendiente de la clase de
trabajo que esos nodos saben realizar.

En nuestro caso particular esto se traduce en que los \ws deben poseer las
capacidades de: \solvear \todo{buscar una forma de decir esto que no sea
tan fea o en su defecto definir esto en la parte de preliminares} un
subproblema (consumir), dividir un subproblema en nuevos subproblemas
(producir) y almacenar, solicitar y transferir subproblemas (distribuir).

El triple rol de productor, consumidor y distribuidor asignado a los \ws hace
que la movilidad de tareas se transforme en un desafío en tanto que un \w
puede estar \solveando al mismo tiempo que otro \w le solicita una tarea
pendiente. Es evidente que en esta situación no es viable que el \w que está
esperando una tarea tenga que esperar a que el \w que tiene dicha tarea
termine de \solvear para que su pedido sea completado.

El objetivo global de escalabilidad también trae aparejada la necesidad de que
el almacenamiento de problemas pendientes de resolución se encuentre
distribuido. Esto se debe a un doble aspecto. Por un lado, la cantidad de
subproblemas producidos puede ser muy grande. Por lo tanto no es viable
requerir que la cantidad de espacio necesario para almacenar todas las tareas
pendientes de resolución se encuentre disponible en una misma ubicación. Menos aún
si pretendemos que nuestro sistema pueda crecer en cantidad de \ws ya que este
crecimiento se traduce también en un crecimiento en la cantidad de productores
y por lo tanto en la cantidad de tareas producidas. Un segundo problema que
presentaría el almacenamiento centralizado es el de la contención. En este
aspecto, si pretendemos que el almacenamiento no se vuelva un cuello de
botella es vital distribuir de la mejor manera posible las tareas pendientes
de modo que cuando los \ws requieran nuevas tareas para resolver, los
múltiples pedidos no recaigan en un mismo equipo.


Otro de los objetivos que perseguimos a la hora de diseñar nuestra herramienta
fue que la misma pudiera utilizar un \ssolver \ots. Esto nos permite
aprovechar los avances que se han obtenido en el área de \ssolving secuencial
en los últimos años (que han sido muchos) a la vez que nos permite, a futuro,
evolucionar a la par de los \ssolvers secuenciales de manera más simple. Esto
proporciona la posibilidad de que la herramienta no se vuelva obsoleta ante un
nuevo avance en \ssolving secuencial.

Generar una estrategia automática que proporcione buenos resultados en la
ejecución de problemas diversos es sumamente difícil. Más aún, no tener la
posibilidad de modificar la estrategia adoptada durante una corrida que puede
ser sumamente larga puede tener resultados catastróficos. Esto nos motivó a
adoptar un enfoque en el que la maquinaria de cómputo distribuido no posee
inteligencia alguna y por el contrario provee una serie de operaciones
básicas. La operación del sistema por lo tanto se lleva a cabo desde un
\textbf{tablero de control} que permite al usuario manipular el sistema de
cómputo.

\

\noindent\underline{\textbf{Nota sobre la implementación}}

\

El último objetivo que perseguimos durante el desarrollo de nuestra herrmienta
fue que la misma presentara facilidad para ser modificada sin que esto
impacatar negativamente en la \emph{performance}. Este objetivo, entre otras
cosas, determinó la elección de las tecnologías a utilizar para su desarrollo.
Por lo tanto se utilizó el lenguaje de programación \Python para el desarrollo
de toda la herramienta con excepción de la parte de cómputo intensivo. Al
utilizar un \ssolver \ots el lenguaje utilizado para el mismo fue aquel en el
que estaba desarrollado. En particular, en la implementación actual de la
herramienta utilizamos el \ssolver \minisatdosveinte que está desarrollado en
el lenguaje \cpp. Para ello se desarrolló un \emph{wrapper} que permite
utilizar \minisat desde un entorno \Python. Para el intercambio de mensajes
entre los \ws se utilizó el estándar \mpi.


% \begin{itemize}
% 	\item Escalable
% 	\item Uso de SAT Solver off-the-shelf
% 	\item Multiplataforma
% 	\item Tablero de control
% \end{itemize}

\section{Arquitectura}

La figura \ref{fig:arquitectura} muestra la arquitectura de la herramienta. En
la misma se distinguen claramente dos componentes: el \bend que ejecuta sobre
un \cluster de computadoras y el \fend que ejecuta en un equipo que se
encuentra posiblemente fuera del centro de cómputos.

\begin{wrapfigure}{o}{0.6\textwidth}
\label{fig:arquitectura}
\fbox{\includegraphics[scale=0.4]{graphs/paralloy architecture}}
\caption{Diagrama de componentes y conectores del \ssolver distribuido}
\end{wrapfigure}

\subsection{\bend}

\newcommand{\master}{\emph{MasterProxy}\xspace}

En el \bend se puede observar que existen dos clases distintas de elementos.
Por un lado tenemos un proceso llamado \master que es el encargado de manejar
la comunicación de órdenes desde el \fend hacia los \ws y de reenviar las
respuestas correspondientes desde los \ws hacia el \fend.

En segunda instancia encontramos otro de tipo de procesos, los \ws. Los \ws
son los encargados de relizar el cómputo (\ssolving). Asimismo son quienes
almacenan las tareas pendientes de ejecución y por lo tanto deben proveer
acceso a dicho almacenamiento a los demás \ws.

\newcommand{\masterslave}{\texttt{Master-Worker}\xspace}

Es importante destacar que si bien el \bend presenta una arquitectura
\masterslave, el \master en este caso no toma ninguna decisión sino que
simplemente actúa como intercambiador de mensajes entre el ambiente externo
(el \fend) y el ambiente interno.

\subsection{\fend}

\begin{figure}
	\begin{subfigure}[b]{0.5\textwidth}
		\centering
		\includegraphics[scale=0.5]{graphs/workerstates}
		\caption{\emph{Workers}}
	\end{subfigure}
	\begin{subfigure}[b]{0.5\textwidth}
		\centering
		\includegraphics[scale=0.5]{graphs/taskstates}
		\caption{Tareas}
	\end{subfigure}
	\caption{Diagramas de estado en el tablero de control}
\end{figure}

\begin{small}
\begin{lstlisting}[language=Python,caption=Interfaz Strategy]
class Strategy(object):
	def register_globalstate(self, globalstate)
	def register_socket(self, commandsocket)
	def on_init(self, worker)
	def on_createroot(self, worker, task)
	def on_init_finished(self, nworkers)
	def on_getfile(self, worker, task)
	def on_file(self, worker, task)
	def on_load(self, worker, task)
	def on_unsat(self, worker, task)
	def on_sat(self, worker, task, modelstr)
	def on_abort(self, worker, task)
	def on_split_newtask(self, worker, newtask)
	def on_split_finished(self, worker, parenttask, nchildren)
	def on_shutdown(self)
\end{lstlisting}
\end{small}

\subsubsection{Nuestra estrategia}

\begin{itemize}
	\item Si idle se parte el más viejo
	\item La próxima a resolver es:
		\begin{itemize}
			\item Si no tengo tareas locales:
				\begin{itemize}
					\item Bajo la tarea que corresponde por BFS +
					\item $\frac{\sharp tasks}{\sharp workers}$ del que más tiene (límite 10)
				\end{itemize}
			\item Si tengo: Agarro la que corresponde por BFS
		\end{itemize}
	\item Parto cuando la frecuencia de $\sharp UNSATs/_s$
\end{itemize}

\subsection{Decisiones que vale la pena seguir investigando}

\section{Resultados experimentales}