%!TEX root = tesis.tex

%\begin{center}
%\large \bf \runtitle
%\end{center}
%\vspace{1cm}
\chapter*{\runtitle}

Today, software is an integral part of our lives, participating in all types of tasks. Text messages, phone calls, the control system of a nuclear power plant or the cruise control setting on a car -- all of these things affect our daily lives and all employ systems based on hardware and software.

In general, software analysis is a field within software engineering responsible for the application of formal methods in order to guarantee (or to at least gain some confidence about) the absence of errors in a software artifact. There is a plethora of tools dedicated to this task, each one with its own particular biases for specific languages and the methods to be applied. Many have turned to the use of off-the-shelf \ssolvers as low-level mechanisms that allow for efficient exploration of a finite space of models.

%The aim of the present work is to implement a parallel and distributed sat-solver that: a) provides an adequate processing workload balance at run-time over an a priori (necesario? no est√° en el original) unknown quantity and configuration of equipment, b) provides an adequate balance of memory use, both primary and secondary, at run-time over an unknown quantity and configuration of equipment, c) is extensible and easy to parameterize in all the relevant aspects that determine the behaviour of the tool in the solution of the problem. Once this task is done, we will evaluate the viability of the implementation of learning techniques based in conflict clause analysis according to the needs of parallel and distributed scenarios, and their empirical comparison.




%Software is nowadays an integral part of our lives. It participates in all
%kind of tasks. From the sending of a text message or the realisation of a
%phone call, to the control system of a nuclear plant or the cruise control
%system of a car use systems based on hardware and software.

%Software analysis is a field in software engineering that in general has the
%responsibility of the application of formal methods in order to guaranty, or
%at least gain some confidence in the absence of errors in a software artifact.
%There exists a plethora of tools dedicated to that task, each one of them with
%their particular biases for specific languages and methods to be applied.
%Among them, there are many that have turn to the use of \ssolvers \emph{off-
%the-shelf}  as a low level mechanism allowing the efficient exploration of a
%finite space of models.
 
The aim of the present work is to implement a parallel and distributed
\ssolver that: \begin{inparaenum}[a)]   \item provides an adequate processing
workload balance at run-time over an \emph{a priori} unknown quantity and
configuration of equipment, \item provides an adequate balance of memory use,
both primary and secondary, at run-time over an unknown quantity and
configuration of equipment, \item is extensible and easy to parameterize in
all the relevant aspects that determines the behaviour of the tool in the
solution of the problem. \end{inparaenum} Once this task is done, we will
evaluate the viability of the implementation of learning techniques based in
conflict clause analysis according to the needs of parallel and distributed
scenarios, and their empirical comparison.

\bigskip

\noindent \textbf{Keywords:} Software engineering, Verification and
validation, Sat-solvers, Parallel and distributed, Conflict based learning.
